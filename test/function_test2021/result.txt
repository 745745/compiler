This is test: 000_main.sy 

int main(){
    return 3;
}

This is test AST: 000_main.sy 

NCompUnit
	NFuncDecl int main
		NReturnStmt 3


This is test IR: 000_main.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 3		



This is test: 001_var_defn.sy 

//test global var define
int a = 3;
int b = 5;

int main(){
    return a + b;
}

This is test AST: 001_var_defn.sy 

NCompUnit
	NVarDecl  int a init [3]
	NVarDecl  int b init [5]
	NFuncDecl int main
		NReturnStmt NBinaryExp NIdentifierExp a + NIdentifierExp b


This is test IR: 001_var_defn.sy 

a
int: a3
b
int: b5
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1			



This is test: 002_var_defn2.sy 

//test domain of global var define and local define
int a = 3;
int b = 5;

int main(){
    int a = 5;
    return a + b;
}

This is test AST: 002_var_defn2.sy 

NCompUnit
	NVarDecl  int a init [3]
	NVarDecl  int b init [5]
	NFuncDecl int main
		NDeclStmt NVarDecl  int a init [5] 
		NReturnStmt NBinaryExp NIdentifierExp a + NIdentifierExp b


This is test IR: 002_var_defn2.sy 

a
int: a3
b
int: b5
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 3
		Alloca argNum:0 
		Store argNum:2 int:5	int: 2		
		Add argNum:2 
Instruction: 		Load argNum:1 int: 2			
Instruction: 		Load argNum:1 int: 1			



This is test: 003_var_defn3.sy 

//test local var define
int main(){
    int a, b0, _c;
    a = 1;
    b0 = 2;
    _c = 3;
    return b0 + _c;
}

This is test AST: 003_var_defn3.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b0 noinit NVarDecl  int _c noinit 
		NAssignStmt a = 1
		NAssignStmt b0 = 2
		NAssignStmt _c = 3
		NReturnStmt NBinaryExp NIdentifierExp b0 + NIdentifierExp _c


This is test IR: 003_var_defn3.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 10
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Store argNum:2 int:1	int: 0		
		Store argNum:2 int:2	int: 1		
		Store argNum:2 int:3	int: 2		
		Add argNum:2 
Instruction: 		Load argNum:1 int: 1			
Instruction: 		Load argNum:1 int: 2			



This is test: 004_arr_defn.sy 

int a[10];
int main(){
	return 0;
}


This is test AST: 004_arr_defn.sy 

NCompUnit
	NVarDecl  int a[10] noinit
	NFuncDecl int main
		NReturnStmt 0


This is test IR: 004_arr_defn.sy 

a
array: a
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		



This is test: 005_arr_defn2.sy 

int a[10][10];
int main(){
    return 0;
}

This is test AST: 005_arr_defn2.sy 

NCompUnit
	NVarDecl  int a[10][10] noinit
	NFuncDecl int main
		NReturnStmt 0


This is test IR: 005_arr_defn2.sy 

a
array: a
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		



This is test: 006_arr_defn3.sy 

//test array define
int main(){
    int a[4][2] = {};
    int b[4][2] = {1, 2, 3, 4, 5, 6, 7, 8};
    int c[4][2] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    int d[4][2] = {1, 2, {3}, {5}, 7 , 8};
    int e[4][2] = {{d[2][1], c[2][1]}, {3, 4}, {5, 6}, {7, 8}};
    return e[3][1] + e[0][0] + e[0][1] + a[2][0];
}

This is test AST: 006_arr_defn3.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a[4][2] init  
		NDeclStmt NVarDecl  int b[4][2] init [1][2][3][4][5][6][7][8] 
		NDeclStmt NVarDecl  int c[4][2] init [1][2][3][4][5][6][7][8] 
		NDeclStmt NVarDecl  int d[4][2] init [1][2][3][5][7][8] 
		NDeclStmt NVarDecl  int e[4][2] init [NIdentifierExp d 2 1][NIdentifierExp c 2 1][3][4][5][6][7][8] 
		NReturnStmt NBinaryExp NBinaryExp NBinaryExp NIdentifierExp e 3 1 + NIdentifierExp e 0 0 + NIdentifierExp e 0 1 + NIdentifierExp a 2 0


This is test IR: 006_arr_defn3.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 6
		Alloca argNum:1 int: 8		
		Alloca argNum:1 int: 8		
		Alloca argNum:1 int: 8		
		Alloca argNum:1 int: 8		
		Alloca argNum:1 int: 8		
		Add argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 2		int:3		
Instruction: 		Mul argNum:2 int: 1		int:1			
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 2		int:0		
Instruction: 		Mul argNum:2 int: 1		int:0				
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 2		int:0		
Instruction: 		Mul argNum:2 int: 1		int:1				
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 2		int:2		
Instruction: 		Mul argNum:2 int: 1		int:0			



This is test: 007_arr_defn4.sy 

int main(){
    const int a[4][2] = {{1, 2}, {3, 4}, {}, 7};
    const int N = 3;
    int b[4][2] = {};
    int c[4][2] = {1, 2, 3, 4, 5, 6, 7, 8};
    int d[N + 1][2] = {1, 2, {3}, {5}, a[3][0], 8};
    int e[4][2][1] = {{d[2][1], {c[2][1]}}, {3, 4}, {5, 6}, {7, 8}};
    return e[3][1][0] + e[0][0][0] + e[0][1][0] + d[3][0];
}


This is test AST: 007_arr_defn4.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl const int a[4][2] init [1][2][3][4][7] 
		NDeclStmt NVarDecl const int N init [3] 
		NDeclStmt NVarDecl  int b[4][2] init  
		NDeclStmt NVarDecl  int c[4][2] init [1][2][3][4][5][6][7][8] 
		NDeclStmt NVarDecl  int d[NBinaryExp NIdentifierExp N + 1][2] init [1][2][3][5][NIdentifierExp a 3 0][8] 
		NDeclStmt NVarDecl  int e[4][2][1] init [NIdentifierExp d 2 1][NIdentifierExp c 2 1][3][4][5][6][7][8] 
		NReturnStmt NBinaryExp NBinaryExp NBinaryExp NIdentifierExp e 3 1 0 + NIdentifierExp e 0 0 0 + NIdentifierExp e 0 1 0 + NIdentifierExp d 3 0


This is test IR: 007_arr_defn4.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 8
		Alloca argNum:1 int: 8		
		Alloca argNum:0 
		Store argNum:2 int:3	int: 8		
		Alloca argNum:1 int: 8		
		Alloca argNum:1 int: 8		
		Alloca argNum:1 int: 8		
		Alloca argNum:1 int: 8		
		Add argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		VectorAdd argNum:3 
Instruction: 		Mul argNum:2 int: 2		int:3		
Instruction: 		Mul argNum:2 int: 2		int:1		
Instruction: 		Mul argNum:2 int: 1		int:0			
Instruction: 		VectorAdd argNum:3 
Instruction: 		Mul argNum:2 int: 2		int:0		
Instruction: 		Mul argNum:2 int: 2		int:0		
Instruction: 		Mul argNum:2 int: 1		int:0				
Instruction: 		VectorAdd argNum:3 
Instruction: 		Mul argNum:2 int: 2		int:0		
Instruction: 		Mul argNum:2 int: 2		int:1		
Instruction: 		Mul argNum:2 int: 1		int:0				
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 2		int:3		
Instruction: 		Mul argNum:2 int: 1		int:0			



This is test: 008_const_var_defn.sy 

//test global var define
const int a = 10;

int main(){
    return a;
}

This is test AST: 008_const_var_defn.sy 

NCompUnit
	NVarDecl const int a init [10]
	NFuncDecl int main
		NReturnStmt NIdentifierExp a


This is test IR: 008_const_var_defn.sy 

a
int: a10
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 0		



This is test: 009_const_var_defn2.sy 

//test const gloal var define
const int a = 10, b = 5;

int main(){
    return b;
}

This is test AST: 009_const_var_defn2.sy 

NCompUnit
	NVarDecl const int a init [10]
	NVarDecl const int b init [5]
	NFuncDecl int main
		NReturnStmt NIdentifierExp b


This is test IR: 009_const_var_defn2.sy 

a
int: a10
b
int: b5
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 1		



This is test: 010_const_var_defn3.sy 

//test const local var define
int main(){
    const int a = 10, b = 5;
    return b;
}

This is test AST: 010_const_var_defn3.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl const int a init [10] NVarDecl const int b init [5] 
		NReturnStmt NIdentifierExp b


This is test IR: 010_const_var_defn3.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 5
		Alloca argNum:0 
		Store argNum:2 int:10	int: 0		
		Alloca argNum:0 
		Store argNum:2 int:5	int: 1		
		Load argNum:1 int: 1		



This is test: 011_const_array_defn.sy 

const int a[5]={0,1,2,3,4};

int main(){
    return a[4];
}

This is test AST: 011_const_array_defn.sy 

NCompUnit
	NVarDecl const int a[5] init [0][1][2][3][4]
	NFuncDecl int main
		NReturnStmt NIdentifierExp a 4


This is test IR: 011_const_array_defn.sy 

a
array: a0 1 2 3 4 
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		VectorAdd argNum:1 
Instruction: 		Mul argNum:2 int: 1		int:4		



This is test: 012_func_defn.sy 

int a;
int func(int p){
	p = p - 1;
	return p;
}
int main(){
	int b;
	a = 10;
	b = func(a);
	return b;
}


This is test AST: 012_func_defn.sy 

NCompUnit
	NVarDecl  int a noinit
	NFuncDecl int func
		NVarDecl  int p noinit
		NAssignStmt p = NBinaryExp NIdentifierExp p - 1
		NReturnStmt NIdentifierExp p
	NFuncDecl int main
		NDeclStmt NVarDecl  int b noinit 
		NAssignStmt a = 10
		NAssignStmt b = NCallExp func NIdentifierExp a
		NReturnStmt NIdentifierExp b


This is test IR: 012_func_defn.sy 

a
int: a
Function: func entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 626484784			int:1		int: 626484784		
		Load argNum:1 int: 626484784		

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 5
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 0		
		Store argNum:2 
Instruction: 		Call argNum:2 
Instruction: 		Load argNum:1 int: 0			Block or something	int: 1		
		Load argNum:1 int: 1		



This is test: 013_var_defn_func.sy 

int defn(){
    return 4;
}

int main(){
    int a=defn();
    return a;
}

This is test AST: 013_var_defn_func.sy 

NCompUnit
	NFuncDecl int defn
		NReturnStmt 4
	NFuncDecl int main
		NDeclStmt NVarDecl  int a init [NCallExp defn] 
		NReturnStmt NIdentifierExp a


This is test IR: 013_var_defn_func.sy 

Function: defn entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 4		

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 3
		Alloca argNum:0 
		Store argNum:2 
Instruction: 		Call argNum:1 Block or something	int: 0		
		Load argNum:1 int: 0		



This is test: 014_add.sy 

//test add
int main(){
    int a, b;
    a = 10;
    b = 2;
    return a + b;
}

This is test AST: 014_add.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit 
		NAssignStmt a = 10
		NAssignStmt b = 2
		NReturnStmt NBinaryExp NIdentifierExp a + NIdentifierExp b


This is test IR: 014_add.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 7
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 0		
		Store argNum:2 int:2	int: 1		
		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1			



This is test: 015_add2.sy 

//test add
int main(){
    int a, b;
    a = 10;
    b = -1;
    return a + b;
}

This is test AST: 015_add2.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit 
		NAssignStmt a = 10
		NAssignStmt b = NUnaryExp 277 1
		NReturnStmt NBinaryExp NIdentifierExp a + NIdentifierExp b


This is test IR: 015_add2.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 7
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 0		
		Store argNum:2 
Instruction: 		Sub argNum:1 int:1		int: 1		
		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1			



This is test: 016_addc.sy 

//test addc
const int a = 10;
int main(){
    return a + 5;
}

This is test AST: 016_addc.sy 

NCompUnit
	NVarDecl const int a init [10]
	NFuncDecl int main
		NReturnStmt NBinaryExp NIdentifierExp a + 5


This is test IR: 016_addc.sy 

a
int: a10
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			int:5	



This is test: 017_sub.sy 

//test sub
int main(){
    int a, b;
    a = 10;
    b = 2;
    return a - b;
}

This is test AST: 017_sub.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit 
		NAssignStmt a = 10
		NAssignStmt b = 2
		NReturnStmt NBinaryExp NIdentifierExp a - NIdentifierExp b


This is test IR: 017_sub.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 7
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 0		
		Store argNum:2 int:2	int: 1		
		Sub argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1			



This is test: 018_sub2.sy 

//test sub
const int a = 10;
int main(){
    int b;
    b = 2;
    return b - a;
}

This is test AST: 018_sub2.sy 

NCompUnit
	NVarDecl const int a init [10]
	NFuncDecl int main
		NDeclStmt NVarDecl  int b noinit 
		NAssignStmt b = 2
		NReturnStmt NBinaryExp NIdentifierExp b - NIdentifierExp a


This is test IR: 018_sub2.sy 

a
int: a10
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:2	int: 1		
		Sub argNum:2 
Instruction: 		Load argNum:1 int: 1			
Instruction: 		Load argNum:1 int: 0			



This is test: 019_subc.sy 

//test subc
int main(){
    int a;
    a = 10;
    return a - 2;
}

This is test AST: 019_subc.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 10
		NReturnStmt NBinaryExp NIdentifierExp a - 2


This is test IR: 019_subc.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:10	int: 0		
		Sub argNum:2 
Instruction: 		Load argNum:1 int: 0			int:2	



This is test: 020_mul.sy 

//test mul
int main(){
    int a, b;
    a = 10;
    b = 5;
    return a * b;
}

This is test AST: 020_mul.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit 
		NAssignStmt a = 10
		NAssignStmt b = 5
		NReturnStmt NBinaryExp NIdentifierExp a * NIdentifierExp b


This is test IR: 020_mul.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 7
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 0		
		Store argNum:2 int:5	int: 1		
		Mul argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1			



This is test: 021_mulc.sy 

//test mulc
const int a = 5;
int main(){
    return a * 5;
}

This is test AST: 021_mulc.sy 

NCompUnit
	NVarDecl const int a init [5]
	NFuncDecl int main
		NReturnStmt NBinaryExp NIdentifierExp a * 5


This is test IR: 021_mulc.sy 

a
int: a5
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Mul argNum:2 
Instruction: 		Load argNum:1 int: 0			int:5	



This is test: 022_div.sy 

//test div
int main(){
    int a, b;
    a = 10;
    b = 5;
    return a / b;
}

This is test AST: 022_div.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit 
		NAssignStmt a = 10
		NAssignStmt b = 5
		NReturnStmt NBinaryExp NIdentifierExp a / NIdentifierExp b


This is test IR: 022_div.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 7
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 0		
		Store argNum:2 int:5	int: 1		
		Div argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1			



This is test: 023_divc.sy 

//test divc
const int a = 10;
int main(){
    return a / 5;
}

This is test AST: 023_divc.sy 

NCompUnit
	NVarDecl const int a init [10]
	NFuncDecl int main
		NReturnStmt NBinaryExp NIdentifierExp a / 5


This is test IR: 023_divc.sy 

a
int: a10
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Div argNum:2 
Instruction: 		Load argNum:1 int: 0			int:5	



This is test: 024_mod.sy 

//test mod
int main(){
    int a;
    a = 10;
    return a / 3;
}

This is test AST: 024_mod.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 10
		NReturnStmt NBinaryExp NIdentifierExp a / 3


This is test IR: 024_mod.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:10	int: 0		
		Div argNum:2 
Instruction: 		Load argNum:1 int: 0			int:3	



This is test: 025_rem.sy 

//test rem
int main(){
    int a;
    a = 10;
    return a % 3;
}

This is test AST: 025_rem.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 10
		NReturnStmt NBinaryExp NIdentifierExp a % 3


This is test IR: 025_rem.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:10	int: 0		
terminate called after throwing an instance of 'std::out_of_range'
  what():  map::at
Aborted


This is test: 026_if.sy 

int a;

int main(){
	a = 10;
	if( a>0 ){
		return 1;
	}
	return 0;
}


This is test AST: 026_if.sy 

NCompUnit
	NVarDecl  int a noinit
	NFuncDecl int main
		NAssignStmt a = 10
		NIfStmt NBinaryExp NIdentifierExp a > 0 
			True: NBlockStmt
			NReturnStmt 1
		NReturnStmt 0


This is test IR: 026_if.sy 

a
int: a
Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 2
		Store argNum:2 int:10	int: 0		
		Br argNum:2 
Instruction: 		GT argNum:2 
Instruction: 		Load argNum:1 int: 0			int:0		Block or something
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 1		
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		



This is test: 027_if2.sy 

int a;
int main(){
	a = 10;
	if( a>0 ){
		return 1;
	}
	else{
		return 0;
	}
}


This is test AST: 027_if2.sy 

NCompUnit
	NVarDecl  int a noinit
	NFuncDecl int main
		NAssignStmt a = 10
		NIfStmt NBinaryExp NIdentifierExp a > 0 
			True: NBlockStmt
			NReturnStmt 1
			False: NBlockStmt
			NReturnStmt 0


This is test IR: 027_if2.sy 

a
int: a
Function: main entry = 0 succ_bbs_= 2 
    BlockType 0 InstructionListLength = 2
		Store argNum:2 int:10	int: 0		
		Br argNum:3 
Instruction: 		GT argNum:2 
Instruction: 		Load argNum:1 int: 0			int:0		Block or somethingBlock or something
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		
    BlockType 0 InstructionListLength = 0



This is test: 028_if_test1.sy 

// test if-else
int ifElse() {
  int a;
  a = 5;
  if (a == 5) {
    a = 25;
  } else {
    a = a * 2;
  }
  return (a);
}


int main() {
  return (ifElse());
}


This is test AST: 028_if_test1.sy 

NCompUnit
	NFuncDecl int ifElse
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 5
		NIfStmt NBinaryExp NIdentifierExp a == 5 
			True: NBlockStmt
			NAssignStmt a = 25
			False: NBlockStmt
			NAssignStmt a = NBinaryExp NIdentifierExp a * 2
		NReturnStmt NIdentifierExp a
	NFuncDecl int main
		NReturnStmt NCallExp ifElse


This is test IR: 028_if_test1.sy 

Function: ifElse entry = 0 succ_bbs_= 2 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:5	int: 0		
		Br argNum:3 
Instruction: 		EQ argNum:2 
Instruction: 		Load argNum:1 int: 0			int:5		Block or somethingBlock or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 0			int:2		int: 0		
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 0		

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Call argNum:1 Block or something



This is test: 029_if_test2.sy 

// test if-else-if
int ifElseIf() {
  int a;
  a = 5;
  int b;
  b = 10;
  if(a == 6 || b == 0xb) {
    return a;
  }
  else {
    if (b == 10 && a == 1)
      a = 25;
    else if (b == 10 && a == -5)
      a = a + 15;
    else
      a = -+a;
  }

  return a;
}

int main(){
  putint(ifElseIf());
  return 0;
}

This is test AST: 029_if_test2.sy 

NCompUnit
	NFuncDecl int ifElseIf
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 5
		NDeclStmt NVarDecl  int b noinit 
		NAssignStmt b = 10
		NIfStmt NBinaryExp NBinaryExp NIdentifierExp a == 6 | NBinaryExp NIdentifierExp b == 0 
			True: NBlockStmt
			NReturnStmt NIdentifierExp a
			False: NBlockStmt
			NIfStmt NBinaryExp NBinaryExp NIdentifierExp b == 10 & NBinaryExp NIdentifierExp a == 1 
			True: NAssignStmt a = 25
			False: NIfStmt NBinaryExp NBinaryExp NIdentifierExp b == 10 & NBinaryExp NIdentifierExp a == NUnaryExp 277 5 
			True: NAssignStmt a = NBinaryExp NIdentifierExp a + 15
			False: NAssignStmt a = NUnaryExp 277 NUnaryExp 276 NIdentifierExp a
		NReturnStmt NIdentifierExp a
	NFuncDecl int main
		NExpStmt NCallExp putint NCallExp ifElseIf
		NReturnStmt 0


This is test IR: 029_if_test2.sy 

Segmentation fault


This is test: 030_if_test3.sy 

// test if-if-else
int ififElse() {
  int a;
  a = 5;
  int b;
  b = 10;
  if(a == 5)
    if (b == 10) 
      a = 25;
    else 
      a = a + 15;
    
  return (a);
}

int main(){
  return (ififElse());
}


This is test AST: 030_if_test3.sy 

NCompUnit
	NFuncDecl int ififElse
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 5
		NDeclStmt NVarDecl  int b noinit 
		NAssignStmt b = 10
		NIfStmt NBinaryExp NIdentifierExp a == 5 
			True: NIfStmt NBinaryExp NIdentifierExp b == 10 
			True: NAssignStmt a = 25
			False: NAssignStmt a = NBinaryExp NIdentifierExp a + 15
		NReturnStmt NIdentifierExp a
	NFuncDecl int main
		NReturnStmt NCallExp ififElse


This is test IR: 030_if_test3.sy 

Function: ififElse entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 8
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:5	int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 1		
		Store argNum:2 int:25	int: 0		
		Br argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Load argNum:1 int: 1			int:10		Block or something
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			int:15		int: 0		
		Br argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Load argNum:1 int: 0			int:5		Block or something
    BlockType 0 InstructionListLength = 0

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Call argNum:1 Block or something



This is test: 031_if_test4.sy 

// test if-{if-else}
int if_ifElse_() {
  int a;
  a = 5;
  int b;
  b = 10;
  if(a == 5){
    if (b == 10) 
      a = 25;
    else 
      a = a + 15;
  }
  return (a);
}

int main(){
  return (if_ifElse_());
}


This is test AST: 031_if_test4.sy 

NCompUnit
	NFuncDecl int if_ifElse_
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 5
		NDeclStmt NVarDecl  int b noinit 
		NAssignStmt b = 10
		NIfStmt NBinaryExp NIdentifierExp a == 5 
			True: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp b == 10 
			True: NAssignStmt a = 25
			False: NAssignStmt a = NBinaryExp NIdentifierExp a + 15
		NReturnStmt NIdentifierExp a
	NFuncDecl int main
		NReturnStmt NCallExp if_ifElse_


This is test IR: 031_if_test4.sy 

Function: if_ifElse_ entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 6
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:5	int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 1		
    BlockType 0 InstructionListLength = 3
		Store argNum:2 int:25	int: 0		
		Br argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Load argNum:1 int: 1			int:10		Block or something
		Br argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Load argNum:1 int: 0			int:5		Block or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			int:15		int: 0		
    BlockType 0 InstructionListLength = 0

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Call argNum:1 Block or something



This is test: 032_if_test5.sy 

// test if-{if}-else
int if_if_Else() {
  int a;
  a = 5;
  int b;
  b = 10;
  if(a == 5){
    if (b == 10) 
      a = 25;
  }
    else 
      a = a + 15;
  return (a);
}

int main(){
  return (if_if_Else());
}


This is test AST: 032_if_test5.sy 

NCompUnit
	NFuncDecl int if_if_Else
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 5
		NDeclStmt NVarDecl  int b noinit 
		NAssignStmt b = 10
		NIfStmt NBinaryExp NIdentifierExp a == 5 
			True: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp b == 10 
			True: NAssignStmt a = 25
			False: NAssignStmt a = NBinaryExp NIdentifierExp a + 15
		NReturnStmt NIdentifierExp a
	NFuncDecl int main
		NReturnStmt NCallExp if_if_Else


This is test IR: 032_if_test5.sy 

Function: if_if_Else entry = 0 succ_bbs_= 2 
    BlockType 0 InstructionListLength = 8
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:5	int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 1		
		Br argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Load argNum:1 int: 1			int:10		Block or something
		Br argNum:3 
Instruction: 		EQ argNum:2 
Instruction: 		Load argNum:1 int: 0			int:5		Block or somethingBlock or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			int:15		int: 0		
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 0		

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Call argNum:1 Block or something



This is test: 033_while_if.sy 

int get_one(int a) {
  return 1;
}

int deepWhileBr(int a, int b) {
  int c;
  c = a + b;
  while (c < 75) {
    int d;
    d = 42;
    if (c < 100) {
      c = c + d;
      if (c > 99) {
        int e;
        e = d * 2;
        if (get_one(0) == 1) {
          c = e * 2;
        }
      }
    }
  }
  return (c);
}

int main() {
  int p;
  p = 2;
  p = deepWhileBr(p, p);
  putint(p);
  return 0;
}

This is test AST: 033_while_if.sy 

NCompUnit
	NFuncDecl int get_one
		NVarDecl  int a noinit
		NReturnStmt 1
	NFuncDecl int deepWhileBr
		NVarDecl  int a noinit
		NVarDecl  int b noinit
		NDeclStmt NVarDecl  int c noinit 
		NAssignStmt c = NBinaryExp NIdentifierExp a + NIdentifierExp b
		NWhileStmt NBinaryExp NIdentifierExp c < 75 
			While: NBlockStmt
			NDeclStmt NVarDecl  int d noinit 
			NAssignStmt d = 42
			NIfStmt NBinaryExp NIdentifierExp c < 100 
			True: NBlockStmt
			NAssignStmt c = NBinaryExp NIdentifierExp c + NIdentifierExp d
			NIfStmt NBinaryExp NIdentifierExp c > 99 
			True: NBlockStmt
			NDeclStmt NVarDecl  int e noinit 
			NAssignStmt e = NBinaryExp NIdentifierExp d * 2
			NIfStmt NBinaryExp NCallExp get_one 0 == 1 
			True: NBlockStmt
			NAssignStmt c = NBinaryExp NIdentifierExp e * 2
		NReturnStmt NIdentifierExp c
	NFuncDecl int main
		NDeclStmt NVarDecl  int p noinit 
		NAssignStmt p = 2
		NAssignStmt p = NCallExp deepWhileBr NIdentifierExp p NIdentifierExp p
		NExpStmt NCallExp putint NIdentifierExp p
		NReturnStmt 0


This is test IR: 033_while_if.sy 

Function: get_one entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 1		

Function: deepWhileBr entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 3
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: -1773152720			
Instruction: 		Load argNum:1 int: -1773152720				int: 0		
    BlockType 0 InstructionListLength = 3
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:42	int: 1		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1				int: 0		
    BlockType 0 InstructionListLength = 6
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Store argNum:2 
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 1			int:2		int: 2		
		Br argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Call argNum:2 int:0	Block or something	int:1		Block or something
		Br argNum:2 
Instruction: 		GT argNum:2 
Instruction: 		Load argNum:1 int: 0			int:99		Block or something
		Br argNum:2 
Instruction: 		LT argNum:2 
Instruction: 		Load argNum:1 int: 0			int:100		Block or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 2			int:2		int: 0		
    BlockType 0 InstructionListLength = 0

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 5
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Store argNum:2 int:2	int: 3		
		Store argNum:2 
Instruction: 		Call argNum:3 
Instruction: 		Load argNum:1 int: 3			
Instruction: 		Load argNum:1 int: 3			Block or something	int: 3		
		constant argNum:1 int: 0		



This is test: 034_while_test1.sy 

int doubleWhile() {
  int i;
  i = 5;
  int j;
  j = 7;
  while (i < 100) {
    i = i + 30;
    while(j < 100){
      j = j + 6;
    }
    j = j - 100;
  }
  return (j);
}

int main() {
  return doubleWhile();
}


This is test AST: 034_while_test1.sy 

NCompUnit
	NFuncDecl int doubleWhile
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 5
		NDeclStmt NVarDecl  int j noinit 
		NAssignStmt j = 7
		NWhileStmt NBinaryExp NIdentifierExp i < 100 
			While: NBlockStmt
			NAssignStmt i = NBinaryExp NIdentifierExp i + 30
			NWhileStmt NBinaryExp NIdentifierExp j < 100 
			While: NBlockStmt
			NAssignStmt j = NBinaryExp NIdentifierExp j + 6
			NAssignStmt j = NBinaryExp NIdentifierExp j - 100
		NReturnStmt NIdentifierExp j
	NFuncDecl int main
		NReturnStmt NCallExp doubleWhile


This is test IR: 034_while_test1.sy 

Function: doubleWhile entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 6
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:5	int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:7	int: 1		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			int:30		int: 0		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 1			int:6		int: 1		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 1			int:100		int: 1		
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 1		

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Call argNum:1 Block or something



This is test: 035_while_test2.sy 

int FourWhile() {
  int a;
  a = 5;
  int b;
  int c;
  b = 6;
  c = 7;
  int d;
  d = 10;
  while (a < 20) {
    a = a + 3;
    while(b < 10){
      b = b + 1;
      while(c == 7){
        c = c - 1;
        while(d < 20){
          d = d + 3;
        }
        d = d - 1;
      }
      c = c + 1;
    }
    b = b - 2;
  }
  
  return (a + (b + d) + c);
}

int main() {
  return FourWhile();
}


This is test AST: 035_while_test2.sy 

NCompUnit
	NFuncDecl int FourWhile
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 5
		NDeclStmt NVarDecl  int b noinit 
		NDeclStmt NVarDecl  int c noinit 
		NAssignStmt b = 6
		NAssignStmt c = 7
		NDeclStmt NVarDecl  int d noinit 
		NAssignStmt d = 10
		NWhileStmt NBinaryExp NIdentifierExp a < 20 
			While: NBlockStmt
			NAssignStmt a = NBinaryExp NIdentifierExp a + 3
			NWhileStmt NBinaryExp NIdentifierExp b < 10 
			While: NBlockStmt
			NAssignStmt b = NBinaryExp NIdentifierExp b + 1
			NWhileStmt NBinaryExp NIdentifierExp c == 7 
			While: NBlockStmt
			NAssignStmt c = NBinaryExp NIdentifierExp c - 1
			NWhileStmt NBinaryExp NIdentifierExp d < 20 
			While: NBlockStmt
			NAssignStmt d = NBinaryExp NIdentifierExp d + 3
			NAssignStmt d = NBinaryExp NIdentifierExp d - 1
			NAssignStmt c = NBinaryExp NIdentifierExp c + 1
			NAssignStmt b = NBinaryExp NIdentifierExp b - 2
		NReturnStmt NBinaryExp NBinaryExp NIdentifierExp a + NBinaryExp NIdentifierExp b + NIdentifierExp d + NIdentifierExp c
	NFuncDecl int main
		NReturnStmt NCallExp FourWhile


This is test IR: 035_while_test2.sy 

Function: FourWhile entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 12
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:5	int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Store argNum:2 int:6	int: 1		
		Store argNum:2 int:7	int: 2		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Store argNum:2 int:10	int: 3		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			int:3		int: 0		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 1			int:1		int: 1		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 2			int:1		int: 2		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 3			int:3		int: 3		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 3			int:1		int: 3		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 2			int:1		int: 2		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 1			int:2		int: 1		
    BlockType 0 InstructionListLength = 1
		Add argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 1			
Instruction: 		Load argNum:1 int: 3					
Instruction: 		Load argNum:1 int: 2			

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 1
		Call argNum:1 Block or something



This is test: 036_while_test3.sy 

int g;
int h;
int f;
int e;
int EightWhile() {
  int a;
  a = 5;
  int b;
  int c;
  b = 6;
  c = 7;
  int d;
  d = 10;
  while (a < 20) {
    a = a + 3;
    while(b < 10){
      b = b + 1;
      while(c == 7){
        c = c - 1;
        while(d < 20){
          d = d + 3;
          while(e > 1){
            e = e-1;
            while(f > 2){
              f = f -2;
              while(g < 3){
                g = g +10;
                while(h < 10){
                  h = h + 8;
                }
                h = h-1;
              }
              g = g- 8;
            }
            f = f + 1;
          }
          e = e + 1;
        }
        d = d - 1;
      }
      c = c + 1;
    }
    b = b - 2;
  }
  
  return (a + (b + d) + c)-(e + d - g + h);
}

int main() {
  g = 1;
  h = 2;
  e = 4;
  f = 6;
  return EightWhile();
}


This is test AST: 036_while_test3.sy 

NCompUnit
	NVarDecl  int g noinit
	NVarDecl  int h noinit
	NVarDecl  int f noinit
	NVarDecl  int e noinit
	NFuncDecl int EightWhile
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 5
		NDeclStmt NVarDecl  int b noinit 
		NDeclStmt NVarDecl  int c noinit 
		NAssignStmt b = 6
		NAssignStmt c = 7
		NDeclStmt NVarDecl  int d noinit 
		NAssignStmt d = 10
		NWhileStmt NBinaryExp NIdentifierExp a < 20 
			While: NBlockStmt
			NAssignStmt a = NBinaryExp NIdentifierExp a + 3
			NWhileStmt NBinaryExp NIdentifierExp b < 10 
			While: NBlockStmt
			NAssignStmt b = NBinaryExp NIdentifierExp b + 1
			NWhileStmt NBinaryExp NIdentifierExp c == 7 
			While: NBlockStmt
			NAssignStmt c = NBinaryExp NIdentifierExp c - 1
			NWhileStmt NBinaryExp NIdentifierExp d < 20 
			While: NBlockStmt
			NAssignStmt d = NBinaryExp NIdentifierExp d + 3
			NWhileStmt NBinaryExp NIdentifierExp e > 1 
			While: NBlockStmt
			NAssignStmt e = NBinaryExp NIdentifierExp e - 1
			NWhileStmt NBinaryExp NIdentifierExp f > 2 
			While: NBlockStmt
			NAssignStmt f = NBinaryExp NIdentifierExp f - 2
			NWhileStmt NBinaryExp NIdentifierExp g < 3 
			While: NBlockStmt
			NAssignStmt g = NBinaryExp NIdentifierExp g + 10
			NWhileStmt NBinaryExp NIdentifierExp h < 10 
			While: NBlockStmt
			NAssignStmt h = NBinaryExp NIdentifierExp h + 8
			NAssignStmt h = NBinaryExp NIdentifierExp h - 1
			NAssignStmt g = NBinaryExp NIdentifierExp g - 8
			NAssignStmt f = NBinaryExp NIdentifierExp f + 1
			NAssignStmt e = NBinaryExp NIdentifierExp e + 1
			NAssignStmt d = NBinaryExp NIdentifierExp d - 1
			NAssignStmt c = NBinaryExp NIdentifierExp c + 1
			NAssignStmt b = NBinaryExp NIdentifierExp b - 2
		NReturnStmt NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a + NBinaryExp NIdentifierExp b + NIdentifierExp d + NIdentifierExp c - NBinaryExp NBinaryExp NBinaryExp NIdentifierExp e + NIdentifierExp d - NIdentifierExp g + NIdentifierExp h
	NFuncDecl int main
		NAssignStmt g = 1
		NAssignStmt h = 2
		NAssignStmt e = 4
		NAssignStmt f = 6
		NReturnStmt NCallExp EightWhile


This is test IR: 036_while_test3.sy 

e
int: e
f
int: f
g
int: g
h
int: h
Function: EightWhile entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 12
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 4		
		Store argNum:2 int:5	int: 4		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 5		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 6		
		Store argNum:2 int:6	int: 5		
		Store argNum:2 int:7	int: 6		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 7		
		Store argNum:2 int:10	int: 7		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 4			int:3		int: 4		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 5			int:1		int: 5		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 6			int:1		int: 6		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 7			int:3		int: 7		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 3			int:1		int: 3		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 2			int:2		int: 2		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			int:10		int: 0		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 1			int:8		int: 1		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 1			int:1		int: 1		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 0			int:8		int: 0		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 2			int:1		int: 2		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 3			int:1		int: 3		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 7			int:1		int: 7		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 6			int:1		int: 6		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 5			int:2		int: 5		
    BlockType 0 InstructionListLength = 1
		Sub argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 4			
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 5			
Instruction: 		Load argNum:1 int: 7					
Instruction: 		Load argNum:1 int: 6				
Instruction: 		Add argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 3			
Instruction: 		Load argNum:1 int: 7				
Instruction: 		Load argNum:1 int: 0				
Instruction: 		Load argNum:1 int: 1				

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 5
		Store argNum:2 int:1	int: 0		
		Store argNum:2 int:2	int: 1		
		Store argNum:2 int:4	int: 3		
		Store argNum:2 int:6	int: 2		
		Call argNum:1 Block or something



This is test: 037_break.sy 

//test break
int main(){
    int i;
    i = 0;
    int sum;
    sum = 0;
    while(i < 100){
        if(i == 50){
            break;
        }
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

This is test AST: 037_break.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NDeclStmt NVarDecl  int sum noinit 
		NAssignStmt sum = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 100 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp i == 50 
			True: NBlockStmt
			NBreakStmt
			NAssignStmt sum = NBinaryExp NIdentifierExp sum + NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt NIdentifierExp sum


This is test IR: 037_break.sy 

Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 6
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:0	int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:0	int: 1		
    BlockType 0 InstructionListLength = 1
		Jmp argNum:1 Block or something
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 1		



This is test: 039_while_if_test1.sy 

// test while-if
int whileIf() {
  int a;
  a = 0;
  int b;
  b = 0;
  while (a < 100) {
    if (a == 5) {
      b = 25;
    }
    else if (a == 10) {
      b = 42;  
    }
    else {
      b = a * 2;
    }
    a = a + 1;
  }
  return (b);
}


int main(){
  return (whileIf());
}


This is test AST: 039_while_if_test1.sy 

NCompUnit
	NFuncDecl int whileIf
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 0
		NDeclStmt NVarDecl  int b noinit 
		NAssignStmt b = 0
		NWhileStmt NBinaryExp NIdentifierExp a < 100 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp a == 5 
			True: NBlockStmt
			NAssignStmt b = 25
			False: NIfStmt NBinaryExp NIdentifierExp a == 10 
			True: NBlockStmt
			NAssignStmt b = 42
			False: NBlockStmt
			NAssignStmt b = NBinaryExp NIdentifierExp a * 2
			NAssignStmt a = NBinaryExp NIdentifierExp a + 1
		NReturnStmt NIdentifierExp b
	NFuncDecl int main
		NReturnStmt NCallExp whileIf


This is test IR: 039_while_if_test1.sy 

Segmentation fault


This is test: 040_while_if_test2.sy 

int ifWhile() {
  int a;
  a = 0;
  int b;
  b = 3;
  if (a == 5) {
    while(b == 2){
      b = b + 2;
    }
    b = b + 25;
  }
  else 
    while (a < 5) {
      b = b * 2;
      a = a + 1;
    }
  return (b);
}


int main(){
  return (ifWhile());
}


This is test AST: 040_while_if_test2.sy 

NCompUnit
	NFuncDecl int ifWhile
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 0
		NDeclStmt NVarDecl  int b noinit 
		NAssignStmt b = 3
		NIfStmt NBinaryExp NIdentifierExp a == 5 
			True: NBlockStmt
			NWhileStmt NBinaryExp NIdentifierExp b == 2 
			While: NBlockStmt
			NAssignStmt b = NBinaryExp NIdentifierExp b + 2
			NAssignStmt b = NBinaryExp NIdentifierExp b + 25
			False: NWhileStmt NBinaryExp NIdentifierExp a < 5 
			While: NBlockStmt
			NAssignStmt b = NBinaryExp NIdentifierExp b * 2
			NAssignStmt a = NBinaryExp NIdentifierExp a + 1
		NReturnStmt NIdentifierExp b
	NFuncDecl int main
		NReturnStmt NCallExp ifWhile


This is test IR: 040_while_if_test2.sy 

Segmentation fault


This is test: 041_while_if_test3.sy 

int deepWhileBr(int a, int b) {
  int c;
  c = a + b;
  while (c < 75) {
    int d;
    d = 42;
    if (c < 100) {
      c = c + d;
      if (c > 99) {
        int e;
        e = d * 2;
        if (1 == 1) {
          c = e * 2;
        }
      }
    }
  }
  return (c);
}

int main() {
  int p;
  p = 2;
  return deepWhileBr(p, p);
}


This is test AST: 041_while_if_test3.sy 

NCompUnit
	NFuncDecl int deepWhileBr
		NVarDecl  int a noinit
		NVarDecl  int b noinit
		NDeclStmt NVarDecl  int c noinit 
		NAssignStmt c = NBinaryExp NIdentifierExp a + NIdentifierExp b
		NWhileStmt NBinaryExp NIdentifierExp c < 75 
			While: NBlockStmt
			NDeclStmt NVarDecl  int d noinit 
			NAssignStmt d = 42
			NIfStmt NBinaryExp NIdentifierExp c < 100 
			True: NBlockStmt
			NAssignStmt c = NBinaryExp NIdentifierExp c + NIdentifierExp d
			NIfStmt NBinaryExp NIdentifierExp c > 99 
			True: NBlockStmt
			NDeclStmt NVarDecl  int e noinit 
			NAssignStmt e = NBinaryExp NIdentifierExp d * 2
			NIfStmt NBinaryExp 1 == 1 
			True: NBlockStmt
			NAssignStmt c = NBinaryExp NIdentifierExp e * 2
		NReturnStmt NIdentifierExp c
	NFuncDecl int main
		NDeclStmt NVarDecl  int p noinit 
		NAssignStmt p = 2
		NReturnStmt NCallExp deepWhileBr NIdentifierExp p NIdentifierExp p


This is test IR: 041_while_if_test3.sy 

Function: deepWhileBr entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 3
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: -1670224336			
Instruction: 		Load argNum:1 int: -1670224336				int: 0		
    BlockType 0 InstructionListLength = 3
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:42	int: 1		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1				int: 0		
    BlockType 0 InstructionListLength = 6
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Store argNum:2 
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 1			int:2		int: 2		
		Br argNum:2 
Instruction: 		EQ argNum:2 int:1	int:1		Block or something
		Br argNum:2 
Instruction: 		GT argNum:2 
Instruction: 		Load argNum:1 int: 0			int:99		Block or something
		Br argNum:2 
Instruction: 		LT argNum:2 
Instruction: 		Load argNum:1 int: 0			int:100		Block or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 2			int:2		int: 0		
    BlockType 0 InstructionListLength = 0

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Store argNum:2 int:2	int: 3		
		Call argNum:3 
Instruction: 		Load argNum:1 int: 3			
Instruction: 		Load argNum:1 int: 3			Block or something



This is test: 042_arr_expr_len.sy 

const int N = -1;
int arr[N + 2 * 4 - 99 / 99] = {1, 2, 33, 4, 5, 6};

int main() {
  int i = 0, sum = 0;
  while (i < 6) {
    sum = sum + arr[i];
    i = i + 1;
  }
  return sum;
}


This is test AST: 042_arr_expr_len.sy 

NCompUnit
	NVarDecl const int N init [NUnaryExp 277 1]
	NVarDecl  int arr[NBinaryExp NBinaryExp NIdentifierExp N + NBinaryExp 2 * 4 - NBinaryExp 99 / 99] init [1][2][33][4][5][6]
	NFuncDecl int main
		NDeclStmt NVarDecl  int i init [0] NVarDecl  int sum init [0] 
		NWhileStmt NBinaryExp NIdentifierExp i < 6 
			While: NBlockStmt
			NAssignStmt sum = NBinaryExp NIdentifierExp sum + NIdentifierExp arr NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt NIdentifierExp sum


This is test IR: 042_arr_expr_len.sy 

N
int: N-1
arr
array: arr1 2 33 4 5 6 
Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int:0	int: 7		
		Alloca argNum:0 
		Store argNum:2 int:0	int: 8		
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 8			
Instruction: 		VectorAdd argNum:1 
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 7						int: 8		
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 7			int:1		int: 7		
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 8		



This is test: 043_op_priority1.sy 

//test the priority of add and mul
int main(){
    int a, b, c, d;
    a = 10;
    b = 4;
    c = 2;
    d = 2;
    return c + a * b - d; 
}

This is test AST: 043_op_priority1.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit NVarDecl  int c noinit NVarDecl  int d noinit 
		NAssignStmt a = 10
		NAssignStmt b = 4
		NAssignStmt c = 2
		NAssignStmt d = 2
		NReturnStmt NBinaryExp NBinaryExp NIdentifierExp c + NBinaryExp NIdentifierExp a * NIdentifierExp b - NIdentifierExp d


This is test IR: 043_op_priority1.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 13
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Store argNum:2 int:10	int: 0		
		Store argNum:2 int:4	int: 1		
		Store argNum:2 int:2	int: 2		
		Store argNum:2 int:2	int: 3		
		Sub argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 2			
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1					
Instruction: 		Load argNum:1 int: 3			



This is test: 044_op_priority2.sy 

//test the priority of add and mul
int main(){
    int a, b, c, d;
    a = 10;
    b = 4;
    c = 2;
    d = 2;
    return (c + a) * (b - d); 
}

This is test AST: 044_op_priority2.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit NVarDecl  int c noinit NVarDecl  int d noinit 
		NAssignStmt a = 10
		NAssignStmt b = 4
		NAssignStmt c = 2
		NAssignStmt d = 2
		NReturnStmt NBinaryExp NBinaryExp NIdentifierExp c + NIdentifierExp a * NBinaryExp NIdentifierExp b - NIdentifierExp d


This is test IR: 044_op_priority2.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 13
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Store argNum:2 int:10	int: 0		
		Store argNum:2 int:4	int: 1		
		Store argNum:2 int:2	int: 2		
		Store argNum:2 int:2	int: 3		
		Mul argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 2			
Instruction: 		Load argNum:1 int: 0				
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 1			
Instruction: 		Load argNum:1 int: 3				



This is test: 045_op_priority3.sy 

//test the priority of  unary operator and binary operator
int main(){
    int a, b;
    a = 10;
    b = 30;
    return a - -5 + b + -5;
}

This is test AST: 045_op_priority3.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit 
		NAssignStmt a = 10
		NAssignStmt b = 30
		NReturnStmt NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a - NUnaryExp 277 5 + NIdentifierExp b + NUnaryExp 277 5


This is test IR: 045_op_priority3.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 7
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 0		
		Store argNum:2 int:30	int: 1		
		Add argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Sub argNum:1 int:5			
Instruction: 		Load argNum:1 int: 1				
Instruction: 		Sub argNum:1 int:5		



This is test: 046_op_priority4.sy 

int a;
int b;
int c;
int d;
int e;
int main()
{
	a=getint();
	b=getint();
	c=getint();
	d=getint();
	e=getint();
	int flag=0;
	if(a-b*c!=d-a/c||a*b/c==e+d||a+b+c==d+e)
	{
		flag=1;
	}
	return flag;
}


This is test AST: 046_op_priority4.sy 

NCompUnit
	NVarDecl  int a noinit
	NVarDecl  int b noinit
	NVarDecl  int c noinit
	NVarDecl  int d noinit
	NVarDecl  int e noinit
	NFuncDecl int main
		NAssignStmt a = NCallExp getint
		NAssignStmt b = NCallExp getint
		NAssignStmt c = NCallExp getint
		NAssignStmt d = NCallExp getint
		NAssignStmt e = NCallExp getint
		NDeclStmt NVarDecl  int flag init [0] 
		NIfStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a - NBinaryExp NIdentifierExp b * NIdentifierExp c != NBinaryExp NIdentifierExp d - NBinaryExp NIdentifierExp a / NIdentifierExp c | NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a * NIdentifierExp b / NIdentifierExp c == NBinaryExp NIdentifierExp e + NIdentifierExp d | NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a + NIdentifierExp b + NIdentifierExp c == NBinaryExp NIdentifierExp d + NIdentifierExp e 
			True: NBlockStmt
			NAssignStmt flag = 1
		NReturnStmt NIdentifierExp flag


This is test IR: 046_op_priority4.sy 

a
int: a
b
int: b
c
int: c
d
int: d
e
int: e
Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 8
		Store argNum:2 
Segmentation fault


This is test: 047_op_priority5.sy 

int a = 1;
int b = 0;
int c = 1;
int d = 2;
int e = 4;
int main()
{
	int flag=0;
	if(a * b / c == e + d && a * (a + b) + c <= d + e || a - (b * c) == d - a / c)
	{
		flag=1;
	}
	putint(flag);
	return flag;
}

This is test AST: 047_op_priority5.sy 

NCompUnit
	NVarDecl  int a init [1]
	NVarDecl  int b init [0]
	NVarDecl  int c init [1]
	NVarDecl  int d init [2]
	NVarDecl  int e init [4]
	NFuncDecl int main
		NDeclStmt NVarDecl  int flag init [0] 
		NIfStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a * NIdentifierExp b / NIdentifierExp c == NBinaryExp NIdentifierExp e + NIdentifierExp d & NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a * NBinaryExp NIdentifierExp a + NIdentifierExp b + NIdentifierExp c <= NBinaryExp NIdentifierExp d + NIdentifierExp e | NBinaryExp NBinaryExp NIdentifierExp a - NBinaryExp NIdentifierExp b * NIdentifierExp c == NBinaryExp NIdentifierExp d - NBinaryExp NIdentifierExp a / NIdentifierExp c 
			True: NBlockStmt
			NAssignStmt flag = 1
		NExpStmt NCallExp putint NIdentifierExp flag
		NReturnStmt NIdentifierExp flag


This is test IR: 047_op_priority5.sy 

a
int: a1
b
int: b0
c
int: c1
d
int: d2
e
int: e4
Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 3
		Alloca argNum:0 
		Store argNum:2 int:0	int: 5		
		Br argNum:2 
Instruction: 		Or argNum:2 
Instruction: 		And argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Div argNum:2 
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1				
Instruction: 		Load argNum:1 int: 2				
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 4			
Instruction: 		Load argNum:1 int: 3					
Instruction: 		LE argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1					
Instruction: 		Load argNum:1 int: 2				
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 3			
Instruction: 		Load argNum:1 int: 4						
Instruction: 		EQ argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 1			
Instruction: 		Load argNum:1 int: 2					
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 3			
Instruction: 		Div argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 2							Block or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 int:1	int: 5		
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 5		



This is test: 048_stmt_expr.sy 

int k;
const int n = 10;
int main () {
	int i = 0;
	k = 1;
	while (i <= n - 1) {
		i = i + 1;
		k + 1;
		k = k + k;
	}
	putint(k);
	return k;
}


This is test AST: 048_stmt_expr.sy 

NCompUnit
	NVarDecl  int k noinit
	NVarDecl const int n init [10]
	NFuncDecl int main
		NDeclStmt NVarDecl  int i init [0] 
		NAssignStmt k = 1
		NWhileStmt NBinaryExp NIdentifierExp i <= NBinaryExp NIdentifierExp n - 1 
			While: NBlockStmt
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
			NExpStmt NBinaryExp NIdentifierExp k + 1
			NAssignStmt k = NBinaryExp NIdentifierExp k + NIdentifierExp k
		NExpStmt NCallExp putint NIdentifierExp k
		NReturnStmt NIdentifierExp k


This is test IR: 048_stmt_expr.sy 

k
int: k
n
int: n10
Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 3
		Alloca argNum:0 
		Store argNum:2 int:0	int: 2		
		Store argNum:2 int:1	int: 0		
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 2			int:1		int: 2		
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 0				int: 0		
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 0		



This is test: 049_unary_op.sy 

int main() {
    int a;
    a = 10;
    if (+-!!!a) {
        a = - - -1;
    }
    else {
        a = 0;
    }
    return a;
}

This is test AST: 049_unary_op.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 10
		NIfStmt NUnaryExp 276 NUnaryExp 277 NUnaryExp 273 NUnaryExp 273 NUnaryExp 273 NIdentifierExp a 
			True: NBlockStmt
			NAssignStmt a = NUnaryExp 277 NUnaryExp 277 NUnaryExp 277 1
			False: NBlockStmt
			NAssignStmt a = 0
		NReturnStmt NIdentifierExp a


This is test IR: 049_unary_op.sy 

Function: main entry = 0 succ_bbs_= 2 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:10	int: 0		
		Br argNum:3 
Instruction: 		Add argNum:1 
Instruction: 		Sub argNum:1 
Instruction: 		Not argNum:1 
Instruction: 		Not argNum:1 
Instruction: 		Not argNum:1 
Instruction: 		Load argNum:1 int: 0								Block or somethingBlock or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 int:0	int: 0		
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 0		



This is test: 050_unary_op2.sy 

int main() {
    int a, b;
    a = 070;
    b = 0x4;
    a = a - - 4 + + b;
    if (+-!!!a) {
        a = - - -1;
    }
    else {
        a = 0 + + b;
    }
    putint(a);
    return 0;
}

This is test AST: 050_unary_op2.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit 
		NAssignStmt a = 70
		NAssignStmt b = 0
		NAssignStmt a = NBinaryExp NBinaryExp NIdentifierExp a - NUnaryExp 277 4 + NUnaryExp 276 NIdentifierExp b
		NIfStmt NUnaryExp 276 NUnaryExp 277 NUnaryExp 273 NUnaryExp 273 NUnaryExp 273 NIdentifierExp a 
			True: NBlockStmt
			NAssignStmt a = NUnaryExp 277 NUnaryExp 277 NUnaryExp 277 1
			False: NBlockStmt
			NAssignStmt a = NBinaryExp 0 + NUnaryExp 276 NIdentifierExp b
		NExpStmt NCallExp putint NIdentifierExp a
		NReturnStmt 0


This is test IR: 050_unary_op2.sy 

Function: main entry = 0 succ_bbs_= 2 
    BlockType 0 InstructionListLength = 8
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:70	int: 0		
		Store argNum:2 int:0	int: 1		
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Sub argNum:1 int:4			
Instruction: 		Add argNum:1 
Instruction: 		Load argNum:1 int: 1					int: 0		
		Br argNum:3 
Instruction: 		Add argNum:1 
Instruction: 		Sub argNum:1 
Instruction: 		Not argNum:1 
Instruction: 		Not argNum:1 
Instruction: 		Not argNum:1 
Instruction: 		Load argNum:1 int: 0								Block or somethingBlock or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 int:0	
Instruction: 		Add argNum:1 
Instruction: 		Load argNum:1 int: 1					int: 0		
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		



This is test: 051_logi_assign.sy 

int a;
int b;
int main()
{
	a=getint();
	b=getint();
	int c;
	if (a==b&&a!=3) {
		c = 1;
	}
	else {
		c = 0;
	}
	return c;
}


This is test AST: 051_logi_assign.sy 

NCompUnit
	NVarDecl  int a noinit
	NVarDecl  int b noinit
	NFuncDecl int main
		NAssignStmt a = NCallExp getint
		NAssignStmt b = NCallExp getint
		NDeclStmt NVarDecl  int c noinit 
		NIfStmt NBinaryExp NBinaryExp NIdentifierExp a == NIdentifierExp b & NBinaryExp NIdentifierExp a != 3 
			True: NBlockStmt
			NAssignStmt c = 1
			False: NBlockStmt
			NAssignStmt c = 0
		NReturnStmt NIdentifierExp c


This is test IR: 051_logi_assign.sy 

a
int: a
b
int: b
Function: main entry = 0 succ_bbs_= 2 
    BlockType 0 InstructionListLength = 5
		Store argNum:2 
Segmentation fault


This is test: 052_comment1.sy 

//test comment
int main(){
    int a;
    a = 5;
    //int b = 4;
    //a = b + a;
    return a;
}

This is test AST: 052_comment1.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 5
		NReturnStmt NIdentifierExp a


This is test IR: 052_comment1.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:5	int: 0		
		Load argNum:1 int: 0		



This is test: 053_comment2.sy 

//test comment
int main(){
    int a, b;
    a = 10;
    b = 2;
    /*/*
        b = 1;
        // b = 2
    */
    return b;
}

This is test AST: 053_comment2.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit 
		NAssignStmt a = 10
		NAssignStmt b = 2
		NReturnStmt NIdentifierExp b


This is test IR: 053_comment2.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 7
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:10	int: 0		
		Store argNum:2 int:2	int: 1		
		Load argNum:1 int: 1		



This is test: 054_hex_defn.sy 

// test hexadecimal define
int main(){
    int a;
    a = 0xf;
    return a;
}

This is test AST: 054_hex_defn.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 0
		NReturnStmt NIdentifierExp a


This is test IR: 054_hex_defn.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:0	int: 0		
		Load argNum:1 int: 0		



This is test: 055_hex_oct_add.sy 

//test add of hex and oct
int main(){
    int a, b;
    a = 0xf;
    b = 0xc;
    return a + b + 075;
}

This is test AST: 055_hex_oct_add.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit 
		NAssignStmt a = 0
		NAssignStmt b = 0
		NReturnStmt NBinaryExp NBinaryExp NIdentifierExp a + NIdentifierExp b + 75


This is test IR: 055_hex_oct_add.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 7
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:0	int: 0		
		Store argNum:2 int:0	int: 1		
		Add argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1				int:75	



This is test: 056_assign_complex_expr.sy 

// Use complex expression in assign structure
int main () {
    int a;
    int b;
    int c;
    int d;
    int result;
    a = 5;
    b = 5;
    c = 1;
    d = -2;
    result = (d * 1 / 2)  + (a - b) - -(c + 3) % 2;
    putint(result);
    result = ((d % 2 + 67) + -(a - b) - -((c + 2) % 2));
    result = result + 3;
    putint(result);
    return 0;
}


This is test AST: 056_assign_complex_expr.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NDeclStmt NVarDecl  int b noinit 
		NDeclStmt NVarDecl  int c noinit 
		NDeclStmt NVarDecl  int d noinit 
		NDeclStmt NVarDecl  int result noinit 
		NAssignStmt a = 5
		NAssignStmt b = 5
		NAssignStmt c = 1
		NAssignStmt d = NUnaryExp 277 2
		NAssignStmt result = NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp d * 1 / 2 + NBinaryExp NIdentifierExp a - NIdentifierExp b - NBinaryExp NUnaryExp 277 NBinaryExp NIdentifierExp c + 3 % 2
		NExpStmt NCallExp putint NIdentifierExp result
		NAssignStmt result = NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp d % 2 + 67 + NUnaryExp 277 NBinaryExp NIdentifierExp a - NIdentifierExp b - NUnaryExp 277 NBinaryExp NBinaryExp NIdentifierExp c + 2 % 2
		NAssignStmt result = NBinaryExp NIdentifierExp result + 3
		NExpStmt NCallExp putint NIdentifierExp result
		NReturnStmt 0


This is test IR: 056_assign_complex_expr.sy 

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 18
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 4		
		Store argNum:2 int:5	int: 0		
		Store argNum:2 int:5	int: 1		
		Store argNum:2 int:1	int: 2		
		Store argNum:2 
Instruction: 		Sub argNum:1 int:2		int: 3		
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Div argNum:2 
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 3			int:1		int:2		
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: 1					
terminate called after throwing an instance of 'std::out_of_range'
  what():  map::at
Aborted


This is test: 057_if_complex_expr.sy 

// Use complex expression in if structure
int main () {
    int a;
    int b;
    int c;
    int d;
    int result;
    a = 5;
    b = 5;
    c = 1;
    d = -2;
    result = 2;
    if ((d * 1 / 2) < 0 || (a - b) != 0 && (c + 3) % 2 != 0) {
        putint(result);
    }
    if ((d % 2 + 67) < 0 || (a - b) != 0 && (c + 2) % 2 != 0) {
        result = 4;
        putint(result);
    }
    return 0;
}


This is test AST: 057_if_complex_expr.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NDeclStmt NVarDecl  int b noinit 
		NDeclStmt NVarDecl  int c noinit 
		NDeclStmt NVarDecl  int d noinit 
		NDeclStmt NVarDecl  int result noinit 
		NAssignStmt a = 5
		NAssignStmt b = 5
		NAssignStmt c = 1
		NAssignStmt d = NUnaryExp 277 2
		NAssignStmt result = 2
		NIfStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp d * 1 / 2 < 0 | NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a - NIdentifierExp b != 0 & NBinaryExp NBinaryExp NBinaryExp NIdentifierExp c + 3 % 2 != 0 
			True: NBlockStmt
			NExpStmt NCallExp putint NIdentifierExp result
		NIfStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp d % 2 + 67 < 0 | NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a - NIdentifierExp b != 0 & NBinaryExp NBinaryExp NBinaryExp NIdentifierExp c + 2 % 2 != 0 
			True: NBlockStmt
			NAssignStmt result = 4
			NExpStmt NCallExp putint NIdentifierExp result
		NReturnStmt 0


This is test IR: 057_if_complex_expr.sy 

Segmentation fault


This is test: 058_short_circuit.sy 

int g = 0;

int func(int n) {
  g = g + n;
  putint(g);
  return g;
}

int main() {
  int i;
  i = getint();
  if (i > 10 && func(i)) i = 1; else i = 0;
  i = getint();
  if (i > 11 && func(i)) i = 1; else i = 0;
  i = getint();
  if (i <= 99 || func(i)) i = 1; else i = 0;
  i = getint();
  if (i <= 100 || func(i)) i = 1; else i = 0;
  if (!func(99) && func(100)) i = 1; else i = 0;
  return 0;
}


This is test AST: 058_short_circuit.sy 

NCompUnit
	NVarDecl  int g init [0]
	NFuncDecl int func
		NVarDecl  int n noinit
		NAssignStmt g = NBinaryExp NIdentifierExp g + NIdentifierExp n
		NExpStmt NCallExp putint NIdentifierExp g
		NReturnStmt NIdentifierExp g
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = NCallExp getint
		NIfStmt NBinaryExp NBinaryExp NIdentifierExp i > 10 & NCallExp func NIdentifierExp i 
			True: NAssignStmt i = 1
			False: NAssignStmt i = 0
		NAssignStmt i = NCallExp getint
		NIfStmt NBinaryExp NBinaryExp NIdentifierExp i > 11 & NCallExp func NIdentifierExp i 
			True: NAssignStmt i = 1
			False: NAssignStmt i = 0
		NAssignStmt i = NCallExp getint
		NIfStmt NBinaryExp NBinaryExp NIdentifierExp i <= 99 | NCallExp func NIdentifierExp i 
			True: NAssignStmt i = 1
			False: NAssignStmt i = 0
		NAssignStmt i = NCallExp getint
		NIfStmt NBinaryExp NBinaryExp NIdentifierExp i <= 100 | NCallExp func NIdentifierExp i 
			True: NAssignStmt i = 1
			False: NAssignStmt i = 0
		NIfStmt NBinaryExp NUnaryExp 273 NCallExp func 99 & NCallExp func 100 
			True: NAssignStmt i = 1
			False: NAssignStmt i = 0
		NReturnStmt 0


This is test IR: 058_short_circuit.sy 

g
int: g0
Function: func entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Load argNum:1 int: -1948228048				int: 0		
		Load argNum:1 int: 0		

Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 5
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 
Segmentation fault


This is test: 059_short_circuit2.sy 

int func(int n) {
  if (n <= 50) {
    putint(n);
    return 1;
  }
  else {
    putint(n);
    return 0;
  }
}

int main() {
  int i;

  if (func(0) == 1 || func(50) == 1 && func(100) == 0)
    i = 0;
  else
    i = 1;
  
  if (func(50) == 1 && func(40) == 1 || func(1) == 1 )
    i = 0;
  else
    i = 1;

  return 0;
}


This is test AST: 059_short_circuit2.sy 

NCompUnit
	NFuncDecl int func
		NVarDecl  int n noinit
		NIfStmt NBinaryExp NIdentifierExp n <= 50 
			True: NBlockStmt
			NExpStmt NCallExp putint NIdentifierExp n
			NReturnStmt 1
			False: NBlockStmt
			NExpStmt NCallExp putint NIdentifierExp n
			NReturnStmt 0
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit 
		NIfStmt NBinaryExp NBinaryExp NCallExp func 0 == 1 | NBinaryExp NBinaryExp NCallExp func 50 == 1 & NBinaryExp NCallExp func 100 == 0 
			True: NAssignStmt i = 0
			False: NAssignStmt i = 1
		NIfStmt NBinaryExp NBinaryExp NBinaryExp NCallExp func 50 == 1 & NBinaryExp NCallExp func 40 == 1 | NBinaryExp NCallExp func 1 == 1 
			True: NAssignStmt i = 0
			False: NAssignStmt i = 1
		NReturnStmt 0


This is test IR: 059_short_circuit2.sy 

Function: func entry = 0 succ_bbs_= 2 
    BlockType 0 InstructionListLength = 2
		constant argNum:1 int: 1		
		Br argNum:3 
Instruction: 		LE argNum:2 
Instruction: 		Load argNum:1 int: -690227664			int:50		Block or somethingBlock or something
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		
    BlockType 0 InstructionListLength = 0

Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 4
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:0	int: 0		
		Br argNum:2 
Instruction: 		Or argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Call argNum:2 int:0	Block or something	int:1		
Instruction: 		And argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Call argNum:2 int:50	Block or something	int:1		
Instruction: 		EQ argNum:2 
Instruction: 		Call argNum:2 int:100	Block or something	int:0				Block or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 int:1	int: 0		
    BlockType 0 InstructionListLength = 2
		Store argNum:2 int:0	int: 0		
		Br argNum:2 
Instruction: 		Or argNum:2 
Instruction: 		And argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Call argNum:2 int:50	Block or something	int:1		
Instruction: 		EQ argNum:2 
Instruction: 		Call argNum:2 int:40	Block or something	int:1			
Instruction: 		EQ argNum:2 
Instruction: 		Call argNum:2 int:1	Block or something	int:1			Block or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 int:1	int: 0		
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		



This is test: 060_scope.sy 

int a = 7;

int func() {
	int b = a;
	int a = 1;
	if (a == b) {
		a = a + 1;
		return 1;
	}
	else
		return 0;
}

int main() {
	int result = 0;
	int i = 0;
	while (i < 100) {
		if (func() == 1)
			result = result + 1;
		i = i + 1;
	}
	if (result < 100)
		putint(1);
	else
		putint(0);
	return 0;
}


This is test AST: 060_scope.sy 

NCompUnit
	NVarDecl  int a init [7]
	NFuncDecl int func
		NDeclStmt NVarDecl  int b init [NIdentifierExp a] 
		NDeclStmt NVarDecl  int a init [1] 
		NIfStmt NBinaryExp NIdentifierExp a == NIdentifierExp b 
			True: NBlockStmt
			NAssignStmt a = NBinaryExp NIdentifierExp a + 1
			NReturnStmt 1
			False: NReturnStmt 0
	NFuncDecl int main
		NDeclStmt NVarDecl  int result init [0] 
		NDeclStmt NVarDecl  int i init [0] 
		NWhileStmt NBinaryExp NIdentifierExp i < 100 
			While: NBlockStmt
			NIfStmt NBinaryExp NCallExp func == 1 
			True: NAssignStmt result = NBinaryExp NIdentifierExp result + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NIfStmt NBinaryExp NIdentifierExp result < 100 
			True: NExpStmt NCallExp putint 1
			False: NExpStmt NCallExp putint 0
		NReturnStmt 0


This is test IR: 060_scope.sy 

a
int: a7
Function: func entry = 0 succ_bbs_= 2 
    BlockType 0 InstructionListLength = 5
		Alloca argNum:0 
		Store argNum:2 
Instruction: 		Load argNum:1 int: 0			int: 1		
		Alloca argNum:0 
		Store argNum:2 int:1	int: 2		
		Br argNum:3 
Instruction: 		EQ argNum:2 
Instruction: 		Load argNum:1 int: 2			
Instruction: 		Load argNum:1 int: 1				Block or somethingBlock or something
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		
    BlockType 0 InstructionListLength = 0

Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 5
		Alloca argNum:0 
		Store argNum:2 int:0	int: 3		
		Alloca argNum:0 
		Store argNum:2 int:0	int: 4		
		Br argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Call argNum:1 Block or something	int:1		Block or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 3			int:1		int: 3		



This is test: 061_sort_test1.sy 

int n;
int bubblesort(int arr[])
{
    int i;
    int j;
    i =0; 
    while(i < n-1){
    // Last i elements are already in place
        j = 0;
        while(j < n-i-1){
            if (arr[j] > arr[j+1]) {
                // swap(&arr[j], &arr[j+1]); 
                int tmp;
                tmp = arr[j+1];
                arr[j+1] = arr[j];
                arr[j] = tmp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return 0;
}

int main(){
    n = 10;
    int a[10];
    a[0]=4;a[1]=3;a[2]=9;a[3]=2;a[4]=0;
    a[5]=1;a[6]=6;a[7]=5;a[8]=7;a[9]=8;
    int i;
    i = bubblesort(a);
    while (i < n) {
        int tmp;
        tmp = a[i];
        putint(tmp);
        tmp = 10;
        putch(tmp);
        i = i + 1;
    }
    return 0;
}


This is test AST: 061_sort_test1.sy 

NCompUnit
	NVarDecl  int n noinit
	NFuncDecl int bubblesort
		NVarDecl  int arr noinit
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int j noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NBinaryExp NIdentifierExp n - 1 
			While: NBlockStmt
			NAssignStmt j = 0
			NWhileStmt NBinaryExp NIdentifierExp j < NBinaryExp NBinaryExp NIdentifierExp n - NIdentifierExp i - 1 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp arr NIdentifierExp j > NIdentifierExp arr NBinaryExp NIdentifierExp j + 1 
			True: NBlockStmt
			NDeclStmt NVarDecl  int tmp noinit 
			NAssignStmt tmp = NIdentifierExp arr NBinaryExp NIdentifierExp j + 1
			NAssignStmt arr[NBinaryExp NIdentifierExp j + 1] = NIdentifierExp arr NIdentifierExp j
			NAssignStmt arr[NIdentifierExp j] = NIdentifierExp tmp
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt n = 10
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = 4
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = 2
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = 6
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = NCallExp bubblesort NIdentifierExp a
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NDeclStmt NVarDecl  int tmp noinit 
			NAssignStmt tmp = NIdentifierExp a NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp tmp
			NAssignStmt tmp = 10
			NExpStmt NCallExp putch NIdentifierExp tmp
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0


This is test IR: 061_sort_test1.sy 


undefind global identifier


This is test: 062_sort_test2.sy 

int n;
int insertsort(int a[])
{
    int i;
    i = 1;
    while(i<n)     
    {
        int temp;
        temp=a[i]; 
        int j;
        j=i-1;
        while(j>-1&&temp<a[j])
        {
            a[j+1]=a[j];  
            j = j - 1;
        }
        a[j+1]=temp; 
        i = i + 1;
    }
    return 0;
}

int main(){
    n = 10;
    int a[10];
    a[0]=4;a[1]=3;a[2]=9;a[3]=2;a[4]=0;
    a[5]=1;a[6]=6;a[7]=5;a[8]=7;a[9]=8;
    int i;
    i = insertsort(a);
    while (i < n) {
        int tmp;
        tmp = a[i];
        putint(tmp);
        tmp = 10;
        putch(tmp);
        i = i + 1;
    }
    return 0;
}


This is test AST: 062_sort_test2.sy 

NCompUnit
	NVarDecl  int n noinit
	NFuncDecl int insertsort
		NVarDecl  int a noinit
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 1
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NDeclStmt NVarDecl  int temp noinit 
			NAssignStmt temp = NIdentifierExp a NIdentifierExp i
			NDeclStmt NVarDecl  int j noinit 
			NAssignStmt j = NBinaryExp NIdentifierExp i - 1
			NWhileStmt NBinaryExp NBinaryExp NIdentifierExp j > NUnaryExp 277 1 & NBinaryExp NIdentifierExp temp < NIdentifierExp a NIdentifierExp j 
			While: NBlockStmt
			NAssignStmt a[NBinaryExp NIdentifierExp j + 1] = NIdentifierExp a NIdentifierExp j
			NAssignStmt j = NBinaryExp NIdentifierExp j - 1
			NAssignStmt a[NBinaryExp NIdentifierExp j + 1] = NIdentifierExp temp
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt n = 10
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = 4
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = 2
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = 6
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = NCallExp insertsort NIdentifierExp a
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NDeclStmt NVarDecl  int tmp noinit 
			NAssignStmt tmp = NIdentifierExp a NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp tmp
			NAssignStmt tmp = 10
			NExpStmt NCallExp putch NIdentifierExp tmp
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0


This is test IR: 062_sort_test2.sy 


undefind global identifier


This is test: 063_sort_test3.sy 

int n;
int QuickSort(int arr[], int low, int high)
{
    if (low < high)
    {
        int i;
        i = low;
        int j;
        j = high;
        int k;
        k = arr[low];
        while (i < j)
        {
            while(i < j && arr[j] > k - 1)
            {
                j = j - 1;
            }
 
            if(i < j)
            {
                arr[i] = arr[j];
                i = i + 1;
            }
 
            while(i < j && arr[i] < k)
            {
                i = i + 1;
            }
 
            if(i < j)
            {
                arr[j] = arr[i];
                j = j - 1;
            }
        }
 
        arr[i] = k;
        int tmp;
        tmp = i - 1;
        tmp = QuickSort(arr, low, tmp);
        tmp = i + 1;
        tmp = QuickSort(arr, tmp, high);
    }
    return 0;
}

int main(){
    n = 10;
    int a[10];
    a[0]=4;a[1]=3;a[2]=9;a[3]=2;a[4]=0;
    a[5]=1;a[6]=6;a[7]=5;a[8]=7;a[9]=8;
    int i;
    i = 0;
    int tmp;
    tmp = 9;
    i = QuickSort(a, i, tmp);
    while (i < n) {
        int tmp;
        tmp = a[i];
        putint(tmp);
        tmp = 10;
        putch(tmp);
        i = i + 1;
    }
    return 0;
}


This is test AST: 063_sort_test3.sy 

NCompUnit
	NVarDecl  int n noinit
	NFuncDecl int QuickSort
		NVarDecl  int arr noinit
		NVarDecl  int low noinit
		NVarDecl  int high noinit
		NIfStmt NBinaryExp NIdentifierExp low < NIdentifierExp high 
			True: NBlockStmt
			NDeclStmt NVarDecl  int i noinit 
			NAssignStmt i = NIdentifierExp low
			NDeclStmt NVarDecl  int j noinit 
			NAssignStmt j = NIdentifierExp high
			NDeclStmt NVarDecl  int k noinit 
			NAssignStmt k = NIdentifierExp arr NIdentifierExp low
			NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp j 
			While: NBlockStmt
			NWhileStmt NBinaryExp NBinaryExp NIdentifierExp i < NIdentifierExp j & NBinaryExp NIdentifierExp arr NIdentifierExp j > NBinaryExp NIdentifierExp k - 1 
			While: NBlockStmt
			NAssignStmt j = NBinaryExp NIdentifierExp j - 1
			NIfStmt NBinaryExp NIdentifierExp i < NIdentifierExp j 
			True: NBlockStmt
			NAssignStmt arr[NIdentifierExp i] = NIdentifierExp arr NIdentifierExp j
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
			NWhileStmt NBinaryExp NBinaryExp NIdentifierExp i < NIdentifierExp j & NBinaryExp NIdentifierExp arr NIdentifierExp i < NIdentifierExp k 
			While: NBlockStmt
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
			NIfStmt NBinaryExp NIdentifierExp i < NIdentifierExp j 
			True: NBlockStmt
			NAssignStmt arr[NIdentifierExp j] = NIdentifierExp arr NIdentifierExp i
			NAssignStmt j = NBinaryExp NIdentifierExp j - 1
			NAssignStmt arr[NIdentifierExp i] = NIdentifierExp k
			NDeclStmt NVarDecl  int tmp noinit 
			NAssignStmt tmp = NBinaryExp NIdentifierExp i - 1
			NAssignStmt tmp = NCallExp QuickSort NIdentifierExp arr NIdentifierExp low NIdentifierExp tmp
			NAssignStmt tmp = NBinaryExp NIdentifierExp i + 1
			NAssignStmt tmp = NCallExp QuickSort NIdentifierExp arr NIdentifierExp tmp NIdentifierExp high
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt n = 10
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = 4
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = 2
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = 6
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NDeclStmt NVarDecl  int tmp noinit 
		NAssignStmt tmp = 9
		NAssignStmt i = NCallExp QuickSort NIdentifierExp a NIdentifierExp i NIdentifierExp tmp
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NDeclStmt NVarDecl  int tmp noinit 
			NAssignStmt tmp = NIdentifierExp a NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp tmp
			NAssignStmt tmp = 10
			NExpStmt NCallExp putch NIdentifierExp tmp
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0


This is test IR: 063_sort_test3.sy 


undefind global identifier


This is test: 064_sort_test4.sy 

int n;
int select_sort(int A[],int n)
{
    int i;
    int j;
    int min;
    i =0;
    while(i < n-1)
    {
        min=i;//
        j = i + 1;
        while(j < n)
        {
            if(A[min]>A[j])
            {
                min=j;
            }
            j=j+1;
        }
        if(min!=i)
        {
            int tmp;
            tmp = A[min];
            A[min] = A[i];
            A[i] = tmp;
        }
        i = i + 1;
    }
    return 0;
}

int main(){
    n = 10;
    int a[10];
    a[0]=4;a[1]=3;a[2]=9;a[3]=2;a[4]=0;
    a[5]=1;a[6]=6;a[7]=5;a[8]=7;a[9]=8;
    int i;
    i = 0;
    i = select_sort(a, n);
    while (i < n) {
        int tmp;
        tmp = a[i];
        putint(tmp);
        tmp = 10;
        putch(tmp);
        i = i + 1;
    }
    return 0;
}


This is test AST: 064_sort_test4.sy 

NCompUnit
	NVarDecl  int n noinit
	NFuncDecl int select_sort
		NVarDecl  int A noinit
		NVarDecl  int n noinit
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int j noinit 
		NDeclStmt NVarDecl  int min noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NBinaryExp NIdentifierExp n - 1 
			While: NBlockStmt
			NAssignStmt min = NIdentifierExp i
			NAssignStmt j = NBinaryExp NIdentifierExp i + 1
			NWhileStmt NBinaryExp NIdentifierExp j < NIdentifierExp n 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp A NIdentifierExp min > NIdentifierExp A NIdentifierExp j 
			True: NBlockStmt
			NAssignStmt min = NIdentifierExp j
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
			NIfStmt NBinaryExp NIdentifierExp min != NIdentifierExp i 
			True: NBlockStmt
			NDeclStmt NVarDecl  int tmp noinit 
			NAssignStmt tmp = NIdentifierExp A NIdentifierExp min
			NAssignStmt A[NIdentifierExp min] = NIdentifierExp A NIdentifierExp i
			NAssignStmt A[NIdentifierExp i] = NIdentifierExp tmp
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt n = 10
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = 4
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = 2
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = 6
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NAssignStmt i = NCallExp select_sort NIdentifierExp a NIdentifierExp n
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NDeclStmt NVarDecl  int tmp noinit 
			NAssignStmt tmp = NIdentifierExp a NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp tmp
			NAssignStmt tmp = 10
			NExpStmt NCallExp putch NIdentifierExp tmp
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0


This is test IR: 064_sort_test4.sy 


undefind global identifier


This is test: 065_sort_test5.sy 

int n;
int swap (int array[], int i, int j){
    int temp;
    temp = array[i];
    array[i] = array[j];
    array[j] = temp;
    return 0;  
}
int heap_ajust(int arr[], int start, int end) {  
    int dad;
    dad = start;  
    int son;
    son = dad * 2 + 1;  
    while (son < end + 1) { //   
        if (son < end && arr[son] < arr[son + 1])
            son = son + 1;  
        if (arr[dad] > arr[son])
            return 0;  
        else {
            dad = swap(arr,dad,son);  
            dad = son;  
            son = dad * 2 + 1;  
        }  
    }  
    return 0;  
}  
int heap_sort(int arr[], int len) {  
    int i;  
    int tmp;
    i = len / 2 - 1;
    while ( i > -1) {
        tmp = len - 1;
        tmp = heap_ajust(arr, i, tmp);  
        i = i - 1;
    }    
    i = len - 1;   
    while ( i > 0) {  
        int tmp0;
        tmp0 = 0;
        tmp = swap(arr,tmp0,i);
        tmp = i - 1;
        tmp = heap_ajust(arr, tmp0, tmp);  
        i = i-1;
    }  
    return 0;
}  

int main(){
    n = 10;
    int a[10];
    a[0]=4;a[1]=3;a[2]=9;a[3]=2;a[4]=0;
    a[5]=1;a[6]=6;a[7]=5;a[8]=7;a[9]=8;
    int i;
    i = 0;
    i = heap_sort(a, n);
    while (i < n) {
        int tmp;
        tmp = a[i];
        putint(tmp);
        tmp = 10;
        putch(tmp);
        i = i + 1;
    }
    return 0;
}


This is test AST: 065_sort_test5.sy 

NCompUnit
	NVarDecl  int n noinit
	NFuncDecl int swap
		NVarDecl  int array noinit
		NVarDecl  int i noinit
		NVarDecl  int j noinit
		NDeclStmt NVarDecl  int temp noinit 
		NAssignStmt temp = NIdentifierExp array NIdentifierExp i
		NAssignStmt array[NIdentifierExp i] = NIdentifierExp array NIdentifierExp j
		NAssignStmt array[NIdentifierExp j] = NIdentifierExp temp
		NReturnStmt 0
	NFuncDecl int heap_ajust
		NVarDecl  int arr noinit
		NVarDecl  int start noinit
		NVarDecl  int end noinit
		NDeclStmt NVarDecl  int dad noinit 
		NAssignStmt dad = NIdentifierExp start
		NDeclStmt NVarDecl  int son noinit 
		NAssignStmt son = NBinaryExp NBinaryExp NIdentifierExp dad * 2 + 1
		NWhileStmt NBinaryExp NIdentifierExp son < NBinaryExp NIdentifierExp end + 1 
			While: NBlockStmt
			NIfStmt NBinaryExp NBinaryExp NIdentifierExp son < NIdentifierExp end & NBinaryExp NIdentifierExp arr NIdentifierExp son < NIdentifierExp arr NBinaryExp NIdentifierExp son + 1 
			True: NAssignStmt son = NBinaryExp NIdentifierExp son + 1
			NIfStmt NBinaryExp NIdentifierExp arr NIdentifierExp dad > NIdentifierExp arr NIdentifierExp son 
			True: NReturnStmt 0
			False: NBlockStmt
			NAssignStmt dad = NCallExp swap NIdentifierExp arr NIdentifierExp dad NIdentifierExp son
			NAssignStmt dad = NIdentifierExp son
			NAssignStmt son = NBinaryExp NBinaryExp NIdentifierExp dad * 2 + 1
		NReturnStmt 0
	NFuncDecl int heap_sort
		NVarDecl  int arr noinit
		NVarDecl  int len noinit
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int tmp noinit 
		NAssignStmt i = NBinaryExp NBinaryExp NIdentifierExp len / 2 - 1
		NWhileStmt NBinaryExp NIdentifierExp i > NUnaryExp 277 1 
			While: NBlockStmt
			NAssignStmt tmp = NBinaryExp NIdentifierExp len - 1
			NAssignStmt tmp = NCallExp heap_ajust NIdentifierExp arr NIdentifierExp i NIdentifierExp tmp
			NAssignStmt i = NBinaryExp NIdentifierExp i - 1
		NAssignStmt i = NBinaryExp NIdentifierExp len - 1
		NWhileStmt NBinaryExp NIdentifierExp i > 0 
			While: NBlockStmt
			NDeclStmt NVarDecl  int tmp0 noinit 
			NAssignStmt tmp0 = 0
			NAssignStmt tmp = NCallExp swap NIdentifierExp arr NIdentifierExp tmp0 NIdentifierExp i
			NAssignStmt tmp = NBinaryExp NIdentifierExp i - 1
			NAssignStmt tmp = NCallExp heap_ajust NIdentifierExp arr NIdentifierExp tmp0 NIdentifierExp tmp
			NAssignStmt i = NBinaryExp NIdentifierExp i - 1
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt n = 10
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = 4
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = 2
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = 6
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NAssignStmt i = NCallExp heap_sort NIdentifierExp a NIdentifierExp n
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NDeclStmt NVarDecl  int tmp noinit 
			NAssignStmt tmp = NIdentifierExp a NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp tmp
			NAssignStmt tmp = 10
			NExpStmt NCallExp putch NIdentifierExp tmp
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0


This is test IR: 065_sort_test5.sy 

Segmentation fault


This is test: 066_sort_test6.sy 

int n;

int counting_sort(int ini_arr[], int sorted_arr[], int n) {
	int count_arr[10];
	int i;
    int j;
    int k;
    k = 0;
    i = 0;
    j = 0;
	while(k < 10){
		count_arr[k] = 0;
        k = k + 1;
    }
    while(i < n)
    {
		count_arr[ini_arr[i]] = count_arr[ini_arr[i]] + 1;
        i = i + 1;
    }
    k = 1;
	while(k < 10){
		count_arr[k] = count_arr[k] + count_arr[k - 1];
        k = k + 1;
    }
    j = n;
	while( j > 0){
        count_arr[ini_arr[j - 1]] = count_arr[ini_arr[j - 1]] - 1;
		sorted_arr[count_arr[ini_arr[j - 1]]] = ini_arr[j - 1];
        j = j - 1;
    }
    return 0;
}


int main(){
    n = 10;
    int a[10];
    a[0]=4;a[1]=3;a[2]=9;a[3]=2;a[4]=0;
    a[5]=1;a[6]=6;a[7]=5;a[8]=7;a[9]=8;
    int i;
    i = 0;
    int b[10];
    i = counting_sort(a, b, n);
    while (i < n) {
        int tmp;
        tmp = b[i];
        putint(tmp);
        tmp = 10;
        putch(tmp);
        i = i + 1;
    }
    return 0;
}


This is test AST: 066_sort_test6.sy 

NCompUnit
	NVarDecl  int n noinit
	NFuncDecl int counting_sort
		NVarDecl  int ini_arr noinit
		NVarDecl  int sorted_arr noinit
		NVarDecl  int n noinit
		NDeclStmt NVarDecl  int count_arr[10] noinit 
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int j noinit 
		NDeclStmt NVarDecl  int k noinit 
		NAssignStmt k = 0
		NAssignStmt i = 0
		NAssignStmt j = 0
		NWhileStmt NBinaryExp NIdentifierExp k < 10 
			While: NBlockStmt
			NAssignStmt count_arr[NIdentifierExp k] = 0
			NAssignStmt k = NBinaryExp NIdentifierExp k + 1
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NAssignStmt count_arr[NIdentifierExp ini_arr NIdentifierExp i] = NBinaryExp NIdentifierExp count_arr NIdentifierExp ini_arr NIdentifierExp i + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt k = 1
		NWhileStmt NBinaryExp NIdentifierExp k < 10 
			While: NBlockStmt
			NAssignStmt count_arr[NIdentifierExp k] = NBinaryExp NIdentifierExp count_arr NIdentifierExp k + NIdentifierExp count_arr NBinaryExp NIdentifierExp k - 1
			NAssignStmt k = NBinaryExp NIdentifierExp k + 1
		NAssignStmt j = NIdentifierExp n
		NWhileStmt NBinaryExp NIdentifierExp j > 0 
			While: NBlockStmt
			NAssignStmt count_arr[NIdentifierExp ini_arr NBinaryExp NIdentifierExp j - 1] = NBinaryExp NIdentifierExp count_arr NIdentifierExp ini_arr NBinaryExp NIdentifierExp j - 1 - 1
			NAssignStmt sorted_arr[NIdentifierExp count_arr NIdentifierExp ini_arr NBinaryExp NIdentifierExp j - 1] = NIdentifierExp ini_arr NBinaryExp NIdentifierExp j - 1
			NAssignStmt j = NBinaryExp NIdentifierExp j - 1
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt n = 10
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = 4
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = 2
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = 6
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NDeclStmt NVarDecl  int b[10] noinit 
		NAssignStmt i = NCallExp counting_sort NIdentifierExp a NIdentifierExp b NIdentifierExp n
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NDeclStmt NVarDecl  int tmp noinit 
			NAssignStmt tmp = NIdentifierExp b NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp tmp
			NAssignStmt tmp = 10
			NExpStmt NCallExp putch NIdentifierExp tmp
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0


This is test IR: 066_sort_test6.sy 


undefind global identifier


This is test: 067_sort_test7.sy 

int buf[2][100];

// sort [l, r)
void merge_sort(int l, int r)
{
    if (l + 1 >= r)
        return;

    int mid = (l + r) / 2;
    merge_sort(l, mid);
    merge_sort(mid, r);

    int i = l, j = mid, k = l;
    while (i < mid && j < r) {
        if (buf[0][i] < buf[0][j]) {
            buf[1][k] = buf[0][i];
            i = i + 1;
        } else {
            buf[1][k] = buf[0][j];
            j = j + 1;
        }
        k = k + 1;
    }
    while (i < mid) {
        buf[1][k] = buf[0][i];
        i = i + 1;
        k = k + 1;
    }
    while (j < r) {
        buf[1][k] = buf[0][j];
        j = j + 1;
        k = k + 1;
    }

    while (l < r) {
        buf[0][l] = buf[1][l];
        l = l + 1;
    }
}

int main()
{
    int n = getarray(buf[0]);
    merge_sort(0, n);
    putarray(n, buf[0]);
    return 0;
}


This is test AST: 067_sort_test7.sy 

NCompUnit
	NVarDecl  int buf[2][100] noinit
	NFuncDecl void merge_sort
		NVarDecl  int l noinit
		NVarDecl  int r noinit
		NIfStmt NBinaryExp NBinaryExp NIdentifierExp l + 1 >= NIdentifierExp r 
			True: NReturnStmt 
		NDeclStmt NVarDecl  int mid init [NBinaryExp NBinaryExp NIdentifierExp l + NIdentifierExp r / 2] 
		NExpStmt NCallExp merge_sort NIdentifierExp l NIdentifierExp mid
		NExpStmt NCallExp merge_sort NIdentifierExp mid NIdentifierExp r
		NDeclStmt NVarDecl  int i init [NIdentifierExp l] NVarDecl  int j init [NIdentifierExp mid] NVarDecl  int k init [NIdentifierExp l] 
		NWhileStmt NBinaryExp NBinaryExp NIdentifierExp i < NIdentifierExp mid & NBinaryExp NIdentifierExp j < NIdentifierExp r 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp buf 0 NIdentifierExp i < NIdentifierExp buf 0 NIdentifierExp j 
			True: NBlockStmt
			NAssignStmt buf[1][NIdentifierExp k] = NIdentifierExp buf 0 NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
			False: NBlockStmt
			NAssignStmt buf[1][NIdentifierExp k] = NIdentifierExp buf 0 NIdentifierExp j
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
			NAssignStmt k = NBinaryExp NIdentifierExp k + 1
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp mid 
			While: NBlockStmt
			NAssignStmt buf[1][NIdentifierExp k] = NIdentifierExp buf 0 NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
			NAssignStmt k = NBinaryExp NIdentifierExp k + 1
		NWhileStmt NBinaryExp NIdentifierExp j < NIdentifierExp r 
			While: NBlockStmt
			NAssignStmt buf[1][NIdentifierExp k] = NIdentifierExp buf 0 NIdentifierExp j
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
			NAssignStmt k = NBinaryExp NIdentifierExp k + 1
		NWhileStmt NBinaryExp NIdentifierExp l < NIdentifierExp r 
			While: NBlockStmt
			NAssignStmt buf[0][NIdentifierExp l] = NIdentifierExp buf 1 NIdentifierExp l
			NAssignStmt l = NBinaryExp NIdentifierExp l + 1
	NFuncDecl int main
		NDeclStmt NVarDecl  int n init [NCallExp getarray NIdentifierExp buf 0] 
		NExpStmt NCallExp merge_sort 0 NIdentifierExp n
		NExpStmt NCallExp putarray NIdentifierExp n NIdentifierExp buf 0
		NReturnStmt 0


This is test IR: 067_sort_test7.sy 

Segmentation fault


This is test: 068_genealogical_tree.sy 

int map[10][10];
int indegree[10];
int queue[10];
void topo(int n)
{
	int m=0;
	int t=0;
	int i,j; 
	i=1;
	j=1;
	while(i<=n)
	{
		j=1;
		while(j<=n)
		{
			if(indegree[j]==0)
			{
				
				m=j;
				break;
			}
			j=j+1;
		}
		queue[t]=m;
		t=t+1;
		indegree[m]=-1;
		j=1;
		while(j<=n)
		
		{
			if(map[m][j])
			{
				indegree[j]=indegree[j]-1;
			 } 
			j=j+1;
		}
		i=i+1;
	}
	i=0;
	while(i<n)
	{
		putint(queue[i]); 
		putch(10);
		i=i+1; 
	}
		
}
int main()
{
	int n,p;
	int i=1;
	n=5;

	while(i<=n)
	{
		p=getint();
		while(p!=0)
		{
			map[i][p]=1;
			indegree[p]=indegree[p]+1;
			p=getint();
			
		}
		i=i+1;
	}
	topo(n);
	return 0;
}


This is test AST: 068_genealogical_tree.sy 

NCompUnit
	NVarDecl  int map[10][10] noinit
	NVarDecl  int indegree[10] noinit
	NVarDecl  int queue[10] noinit
	NFuncDecl void topo
		NVarDecl  int n noinit
		NDeclStmt NVarDecl  int m init [0] 
		NDeclStmt NVarDecl  int t init [0] 
		NDeclStmt NVarDecl  int i noinit NVarDecl  int j noinit 
		NAssignStmt i = 1
		NAssignStmt j = 1
		NWhileStmt NBinaryExp NIdentifierExp i <= NIdentifierExp n 
			While: NBlockStmt
			NAssignStmt j = 1
			NWhileStmt NBinaryExp NIdentifierExp j <= NIdentifierExp n 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp indegree NIdentifierExp j == 0 
			True: NBlockStmt
			NAssignStmt m = NIdentifierExp j
			NBreakStmt
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
			NAssignStmt queue[NIdentifierExp t] = NIdentifierExp m
			NAssignStmt t = NBinaryExp NIdentifierExp t + 1
			NAssignStmt indegree[NIdentifierExp m] = NUnaryExp 277 1
			NAssignStmt j = 1
			NWhileStmt NBinaryExp NIdentifierExp j <= NIdentifierExp n 
			While: NBlockStmt
			NIfStmt NIdentifierExp map NIdentifierExp m NIdentifierExp j 
			True: NBlockStmt
			NAssignStmt indegree[NIdentifierExp j] = NBinaryExp NIdentifierExp indegree NIdentifierExp j - 1
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NExpStmt NCallExp putint NIdentifierExp queue NIdentifierExp i
			NExpStmt NCallExp putch 10
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
	NFuncDecl int main
		NDeclStmt NVarDecl  int n noinit NVarDecl  int p noinit 
		NDeclStmt NVarDecl  int i init [1] 
		NAssignStmt n = 5
		NWhileStmt NBinaryExp NIdentifierExp i <= NIdentifierExp n 
			While: NBlockStmt
			NAssignStmt p = NCallExp getint
			NWhileStmt NBinaryExp NIdentifierExp p != 0 
			While: NBlockStmt
			NAssignStmt map[NIdentifierExp i][NIdentifierExp p] = 1
			NAssignStmt indegree[NIdentifierExp p] = NBinaryExp NIdentifierExp indegree NIdentifierExp p + 1
			NAssignStmt p = NCallExp getint
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NExpStmt NCallExp topo NIdentifierExp n
		NReturnStmt 0


This is test IR: 068_genealogical_tree.sy 

indegree
array: indegree
map
array: map
queue
array: queue
Function: topo entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 10
		Alloca argNum:0 
		Store argNum:2 int:0	int: 30		
		Alloca argNum:0 
		Store argNum:2 int:0	int: 31		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 32		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 33		
		Store argNum:2 int:1	int: 32		
		Store argNum:2 int:1	int: 33		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 int:1	int: 33		
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Load argNum:1 int: 33			int: 30		
		Jmp argNum:1 Block or something
    BlockType 0 InstructionListLength = 7
		Load argNum:1 int: 30		
		Store argNum:3 
Instruction: 		Load argNum:1 int: 30			int: 20		
Instruction: 		VectorAdd argNum:1 
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 31					
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 31			int:1		int: 31		
		Sub argNum:1 int:1	
		Store argNum:3 
Instruction: 		Sub argNum:1 int:1		int: 10		
Instruction: 		VectorAdd argNum:1 
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 30					
		Store argNum:2 int:1	int: 33		
		Br argNum:2 
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 10		
Instruction: 		Load argNum:1 int: 30				
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 33					Block or something
    BlockType 0 InstructionListLength = 2
		Sub argNum:2 
Instruction: 		VectorAdd argNum:1 
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 33					int:1	
		Store argNum:3 
Instruction: 		Sub argNum:2 
Instruction: 		VectorAdd argNum:1 
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 33					int:1		int: 10		
Instruction: 		VectorAdd argNum:1 
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 33					
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 33			int:1		int: 33		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 32			int:1		int: 32		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 int:0	int: 32		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 32			int:1		int: 32		
    BlockType 0 InstructionListLength = 0

Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 7
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 34		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 35		
		Alloca argNum:0 
		Store argNum:2 int:1	int: 36		
		Store argNum:2 int:5	int: 34		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Segmentation fault


This is test: 069_greatest_common_divisor.sy 

int fun(int m,int n){
	int rem;			
	while(n > 0){
		rem = m % n;
		m = n;
		n = rem;
	}
	return m;				
}
int main(){
	int n,m;
	int num;
	m=getint();
	n=getint();
	num=fun(m,n);
	putint(num);

	return 0; 
}


This is test AST: 069_greatest_common_divisor.sy 

NCompUnit
	NFuncDecl int fun
		NVarDecl  int m noinit
		NVarDecl  int n noinit
		NDeclStmt NVarDecl  int rem noinit 
		NWhileStmt NBinaryExp NIdentifierExp n > 0 
			While: NBlockStmt
			NAssignStmt rem = NBinaryExp NIdentifierExp m % NIdentifierExp n
			NAssignStmt m = NIdentifierExp n
			NAssignStmt n = NIdentifierExp rem
		NReturnStmt NIdentifierExp m
	NFuncDecl int main
		NDeclStmt NVarDecl  int n noinit NVarDecl  int m noinit 
		NDeclStmt NVarDecl  int num noinit 
		NAssignStmt m = NCallExp getint
		NAssignStmt n = NCallExp getint
		NAssignStmt num = NCallExp fun NIdentifierExp m NIdentifierExp n
		NExpStmt NCallExp putint NIdentifierExp num
		NReturnStmt 0


This is test IR: 069_greatest_common_divisor.sy 

Function: fun entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 2
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
    BlockType 0 InstructionListLength = 3
		Store argNum:2 
terminate called after throwing an instance of 'std::out_of_range'
  what():  map::at
Aborted


This is test: 070_multiplication_puzzle.sy 

int a[6]={10,1,50,50,20,5};
int dp[10][10];
int main()
{
	int n;
	n=6;

	int k,i,t,j,aa;
	k=3;
	while(k<=n)
	{
		i=0;
		while(i<n-k+1)
		{
			j=i+k-1;
			t=i+1;
			while(t<j)
			{
				aa= dp[i][t]+dp[t][j]+a[i]*a[t]*a[j];
				if(!dp[i][j]||aa<dp[i][j])
				{
					dp[i][j]=aa;
				}
				t=t+1;
			}
			i=i+1;
		}
		k=k+1;
	}
	putint(dp[0][n-1]);
	return 0;
}


This is test AST: 070_multiplication_puzzle.sy 

NCompUnit
	NVarDecl  int a[6] init [10][1][50][50][20][5]
	NVarDecl  int dp[10][10] noinit
	NFuncDecl int main
		NDeclStmt NVarDecl  int n noinit 
		NAssignStmt n = 6
		NDeclStmt NVarDecl  int k noinit NVarDecl  int i noinit NVarDecl  int t noinit NVarDecl  int j noinit NVarDecl  int aa noinit 
		NAssignStmt k = 3
		NWhileStmt NBinaryExp NIdentifierExp k <= NIdentifierExp n 
			While: NBlockStmt
			NAssignStmt i = 0
			NWhileStmt NBinaryExp NIdentifierExp i < NBinaryExp NBinaryExp NIdentifierExp n - NIdentifierExp k + 1 
			While: NBlockStmt
			NAssignStmt j = NBinaryExp NBinaryExp NIdentifierExp i + NIdentifierExp k - 1
			NAssignStmt t = NBinaryExp NIdentifierExp i + 1
			NWhileStmt NBinaryExp NIdentifierExp t < NIdentifierExp j 
			While: NBlockStmt
			NAssignStmt aa = NBinaryExp NBinaryExp NIdentifierExp dp NIdentifierExp i NIdentifierExp t + NIdentifierExp dp NIdentifierExp t NIdentifierExp j + NBinaryExp NBinaryExp NIdentifierExp a NIdentifierExp i * NIdentifierExp a NIdentifierExp t * NIdentifierExp a NIdentifierExp j
			NIfStmt NBinaryExp NUnaryExp 273 NIdentifierExp dp NIdentifierExp i NIdentifierExp j | NBinaryExp NIdentifierExp aa < NIdentifierExp dp NIdentifierExp i NIdentifierExp j 
			True: NBlockStmt
			NAssignStmt dp[NIdentifierExp i][NIdentifierExp j] = NIdentifierExp aa
			NAssignStmt t = NBinaryExp NIdentifierExp t + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
			NAssignStmt k = NBinaryExp NIdentifierExp k + 1
		NExpStmt NCallExp putint NIdentifierExp dp 0 NBinaryExp NIdentifierExp n - 1
		NReturnStmt 0


This is test IR: 070_multiplication_puzzle.sy 

a
array: a10 1 50 50 20 5 
dp
array: dp
Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 14
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 16		
		Store argNum:2 int:6	int: 16		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 17		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 18		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 19		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 20		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 21		
		Store argNum:2 int:3	int: 17		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 int:0	int: 18		
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 18			
Instruction: 		Load argNum:1 int: 17				int:1		int: 20		
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 18			int:1		int: 19		
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 10		
Instruction: 		Load argNum:1 int: 18				
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 19					
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 10		
Instruction: 		Load argNum:1 int: 19				
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 20						
Instruction: 		Mul argNum:2 
Instruction: 		Mul argNum:2 
Instruction: 		VectorAdd argNum:1 
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 18					
Instruction: 		VectorAdd argNum:1 
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 19						
Instruction: 		VectorAdd argNum:1 
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 20							int: 21		
		Br argNum:2 
Instruction: 		Or argNum:2 
Instruction: 		Not argNum:1 
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 10		
Instruction: 		Load argNum:1 int: 18				
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 20						
Instruction: 		LT argNum:2 
Instruction: 		Load argNum:1 int: 21			
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 10		
Instruction: 		Load argNum:1 int: 18				
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 20							Block or something
    BlockType 0 InstructionListLength = 2
		Load argNum:1 int: 21		
		Store argNum:3 
Instruction: 		Load argNum:1 int: 21			int: 6		
Instruction: 		VectorAdd argNum:2 
Instruction: 		Mul argNum:2 int: 10		
Instruction: 		Load argNum:1 int: 18				
Instruction: 		Mul argNum:2 int: 1		
Instruction: 		Load argNum:1 int: 20					
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 19			int:1		int: 19		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 18			int:1		int: 18		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 17			int:1		int: 17		
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		



This is test: 071_exchange_array.sy 

int main(){
    int a[5][5] = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5};
    int m, n, i, j;
    m = 2;
    n = 3;
    j = 0;
    while(j < 5){
        i = a[m-1][j];
        a[m-1][j] = a[n-1][j];
        a[n-1][j] = i;
        j = j + 1;
    }
    return a[2][0];
}

This is test AST: 071_exchange_array.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int a[5][5] init [1][1][1][1][1][2][2][2][2][2][3][3][3][3][3][4][4][4][4][4][5][5][5][5][5] 
		NDeclStmt NVarDecl  int m noinit NVarDecl  int n noinit NVarDecl  int i noinit NVarDecl  int j noinit 
		NAssignStmt m = 2
		NAssignStmt n = 3
		NAssignStmt j = 0
		NWhileStmt NBinaryExp NIdentifierExp j < 5 
			While: NBlockStmt
			NAssignStmt i = NIdentifierExp a NBinaryExp NIdentifierExp m - 1 NIdentifierExp j
			NAssignStmt a[NBinaryExp NIdentifierExp m - 1][NIdentifierExp j] = NIdentifierExp a NBinaryExp NIdentifierExp n - 1 NIdentifierExp j
			NAssignStmt a[NBinaryExp NIdentifierExp n - 1][NIdentifierExp j] = NIdentifierExp i
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
		NReturnStmt NIdentifierExp a 2 0


This is test IR: 071_exchange_array.sy 


undefind global identifier


This is test: 072_percolation.sy 

int array[110];
int n;
void init(int n) {
  int i = 1;
  while (i <= n * n + 1) {
    array[i] = -1;
    i = i + 1;
  }
}

int findfa(int a) {
  if (array[a] == a)
    return a;
  else {
    array[a] = findfa(array[a]);
    return array[a];
  }
}
void mmerge(int a, int b) {
  int m = findfa(a);
  int n = findfa(b);
  if (m != n) array[m] = n;
}
int main() {
  int t, m;
  int a, b;
  t = 1;
  while (t) {
    t = t - 1;
    n = 4;
    m = 10;
    int i = 0;
    int flag = 0;
    init(n);
    int k = n * n + 1;

    while (i < m) {
      a = getint();
      b = getint();

      if (!flag) {
        int loc = n * (a - 1) + b;

        array[loc] = loc;
        if (a == 1) {
          array[0] = 0;
          mmerge(loc, 0);
        }
        if (a == n) {
          array[k] = k;
          mmerge(loc, k);
        }
        if (b < n && array[loc + 1] != -1) {
          mmerge(loc, loc + 1);
        }
        if (b > 1 && array[loc - 1] != -1) {
          mmerge(loc, loc - 1);
        }
        if (a < n && array[loc + n] != -1) {
          mmerge(loc, loc + n);
        }
        if (a > 1 && array[loc - n] != -1) {
          mmerge(loc, loc - n);
        }

        if (array[0] != -1 && array[k] != -1 && findfa(0) == findfa(k)) {
          flag = 1;
          int tmp = i + 1;
          putint(tmp);
          putch(10);
        }
      }

      i = i + 1;
    }
    if (!flag) {
      putint(-1);
      putch(10);
    }
  }
  return 0;
}


This is test AST: 072_percolation.sy 

NCompUnit
	NVarDecl  int array[110] noinit
	NVarDecl  int n noinit
	NFuncDecl void init
		NVarDecl  int n noinit
		NDeclStmt NVarDecl  int i init [1] 
		NWhileStmt NBinaryExp NIdentifierExp i <= NBinaryExp NBinaryExp NIdentifierExp n * NIdentifierExp n + 1 
			While: NBlockStmt
			NAssignStmt array[NIdentifierExp i] = NUnaryExp 277 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
	NFuncDecl int findfa
		NVarDecl  int a noinit
		NIfStmt NBinaryExp NIdentifierExp array NIdentifierExp a == NIdentifierExp a 
			True: NReturnStmt NIdentifierExp a
			False: NBlockStmt
			NAssignStmt array[NIdentifierExp a] = NCallExp findfa NIdentifierExp array NIdentifierExp a
			NReturnStmt NIdentifierExp array NIdentifierExp a
	NFuncDecl void mmerge
		NVarDecl  int a noinit
		NVarDecl  int b noinit
		NDeclStmt NVarDecl  int m init [NCallExp findfa NIdentifierExp a] 
		NDeclStmt NVarDecl  int n init [NCallExp findfa NIdentifierExp b] 
		NIfStmt NBinaryExp NIdentifierExp m != NIdentifierExp n 
			True: NAssignStmt array[NIdentifierExp m] = NIdentifierExp n
	NFuncDecl int main
		NDeclStmt NVarDecl  int t noinit NVarDecl  int m noinit 
		NDeclStmt NVarDecl  int a noinit NVarDecl  int b noinit 
		NAssignStmt t = 1
		NWhileStmt NIdentifierExp t 
			While: NBlockStmt
			NAssignStmt t = NBinaryExp NIdentifierExp t - 1
			NAssignStmt n = 4
			NAssignStmt m = 10
			NDeclStmt NVarDecl  int i init [0] 
			NDeclStmt NVarDecl  int flag init [0] 
			NExpStmt NCallExp init NIdentifierExp n
			NDeclStmt NVarDecl  int k init [NBinaryExp NBinaryExp NIdentifierExp n * NIdentifierExp n + 1] 
			NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp m 
			While: NBlockStmt
			NAssignStmt a = NCallExp getint
			NAssignStmt b = NCallExp getint
			NIfStmt NUnaryExp 273 NIdentifierExp flag 
			True: NBlockStmt
			NDeclStmt NVarDecl  int loc init [NBinaryExp NBinaryExp NIdentifierExp n * NBinaryExp NIdentifierExp a - 1 + NIdentifierExp b] 
			NAssignStmt array[NIdentifierExp loc] = NIdentifierExp loc
			NIfStmt NBinaryExp NIdentifierExp a == 1 
			True: NBlockStmt
			NAssignStmt array[0] = 0
			NExpStmt NCallExp mmerge NIdentifierExp loc 0
			NIfStmt NBinaryExp NIdentifierExp a == NIdentifierExp n 
			True: NBlockStmt
			NAssignStmt array[NIdentifierExp k] = NIdentifierExp k
			NExpStmt NCallExp mmerge NIdentifierExp loc NIdentifierExp k
			NIfStmt NBinaryExp NBinaryExp NIdentifierExp b < NIdentifierExp n & NBinaryExp NIdentifierExp array NBinaryExp NIdentifierExp loc + 1 != NUnaryExp 277 1 
			True: NBlockStmt
			NExpStmt NCallExp mmerge NIdentifierExp loc NBinaryExp NIdentifierExp loc + 1
			NIfStmt NBinaryExp NBinaryExp NIdentifierExp b > 1 & NBinaryExp NIdentifierExp array NBinaryExp NIdentifierExp loc - 1 != NUnaryExp 277 1 
			True: NBlockStmt
			NExpStmt NCallExp mmerge NIdentifierExp loc NBinaryExp NIdentifierExp loc - 1
			NIfStmt NBinaryExp NBinaryExp NIdentifierExp a < NIdentifierExp n & NBinaryExp NIdentifierExp array NBinaryExp NIdentifierExp loc + NIdentifierExp n != NUnaryExp 277 1 
			True: NBlockStmt
			NExpStmt NCallExp mmerge NIdentifierExp loc NBinaryExp NIdentifierExp loc + NIdentifierExp n
			NIfStmt NBinaryExp NBinaryExp NIdentifierExp a > 1 & NBinaryExp NIdentifierExp array NBinaryExp NIdentifierExp loc - NIdentifierExp n != NUnaryExp 277 1 
			True: NBlockStmt
			NExpStmt NCallExp mmerge NIdentifierExp loc NBinaryExp NIdentifierExp loc - NIdentifierExp n
			NIfStmt NBinaryExp NBinaryExp NBinaryExp NIdentifierExp array 0 != NUnaryExp 277 1 & NBinaryExp NIdentifierExp array NIdentifierExp k != NUnaryExp 277 1 & NBinaryExp NCallExp findfa 0 == NCallExp findfa NIdentifierExp k 
			True: NBlockStmt
			NAssignStmt flag = 1
			NDeclStmt NVarDecl  int tmp init [NBinaryExp NIdentifierExp i + 1] 
			NExpStmt NCallExp putint NIdentifierExp tmp
			NExpStmt NCallExp putch 10
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
			NIfStmt NUnaryExp 273 NIdentifierExp flag 
			True: NBlockStmt
			NExpStmt NCallExp putint NUnaryExp 277 1
			NExpStmt NCallExp putch 10
		NReturnStmt 0


This is test IR: 072_percolation.sy 

Segmentation fault


This is test: 073_backpack.sy 

int V[200][200]={};
int KnapSack(int n, int w[], int v[], int x[], int C)
{
    int i, j;
    i=1;
    while(i<=n)
    {
    	j=0;
    	while(j<C+1)
    	{
    		if (j<w[i])
                V[i][j] = V[i - 1][j];
            else
            {
            	int tmp1=V[i - 1][j];
            	int tmp2=V[i - 1][j - w[i]] + v[i];
            	if(tmp1>tmp2)
            	{
            		V[i][j] = tmp1;
				}
				else
				{
					V[i][j] = tmp2;
				}
            	
			}
    		j=j+1;
		}
		i=i+1;
	}
    
    j = C;
    i=n;
    while(i>=1)
    {
    	if (V[i][j]>V[i - 1][j])
        {
            x[i] = 1;
            j = j - w[i];
        }
        else
        {
		 
            x[i] = 0;
        } 
        i=i-1;
	}
    return V[n][C];
}

int main()
{
    int s;
    int w[6] = {0,2,2,6,5,4};
    int v[6] = {0,6,3,5,4,6};
    int x[6];
    int n = 5;
    int C=10;
    s = KnapSack(n, w, v, x, C);
    putint(s);
    return 0;

}


This is test AST: 073_backpack.sy 

NCompUnit
	NVarDecl  int V[200][200] init 
	NFuncDecl int KnapSack
		NVarDecl  int n noinit
		NVarDecl  int w noinit
		NVarDecl  int v noinit
		NVarDecl  int x noinit
		NVarDecl  int C noinit
		NDeclStmt NVarDecl  int i noinit NVarDecl  int j noinit 
		NAssignStmt i = 1
		NWhileStmt NBinaryExp NIdentifierExp i <= NIdentifierExp n 
			While: NBlockStmt
			NAssignStmt j = 0
			NWhileStmt NBinaryExp NIdentifierExp j < NBinaryExp NIdentifierExp C + 1 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp j < NIdentifierExp w NIdentifierExp i 
			True: NAssignStmt V[NIdentifierExp i][NIdentifierExp j] = NIdentifierExp V NBinaryExp NIdentifierExp i - 1 NIdentifierExp j
			False: NBlockStmt
			NDeclStmt NVarDecl  int tmp1 init [NIdentifierExp V NBinaryExp NIdentifierExp i - 1 NIdentifierExp j] 
			NDeclStmt NVarDecl  int tmp2 init [NBinaryExp NIdentifierExp V NBinaryExp NIdentifierExp i - 1 NBinaryExp NIdentifierExp j - NIdentifierExp w NIdentifierExp i + NIdentifierExp v NIdentifierExp i] 
			NIfStmt NBinaryExp NIdentifierExp tmp1 > NIdentifierExp tmp2 
			True: NBlockStmt
			NAssignStmt V[NIdentifierExp i][NIdentifierExp j] = NIdentifierExp tmp1
			False: NBlockStmt
			NAssignStmt V[NIdentifierExp i][NIdentifierExp j] = NIdentifierExp tmp2
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt j = NIdentifierExp C
		NAssignStmt i = NIdentifierExp n
		NWhileStmt NBinaryExp NIdentifierExp i >= 1 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp V NIdentifierExp i NIdentifierExp j > NIdentifierExp V NBinaryExp NIdentifierExp i - 1 NIdentifierExp j 
			True: NBlockStmt
			NAssignStmt x[NIdentifierExp i] = 1
			NAssignStmt j = NBinaryExp NIdentifierExp j - NIdentifierExp w NIdentifierExp i
			False: NBlockStmt
			NAssignStmt x[NIdentifierExp i] = 0
			NAssignStmt i = NBinaryExp NIdentifierExp i - 1
		NReturnStmt NIdentifierExp V NIdentifierExp n NIdentifierExp C
	NFuncDecl int main
		NDeclStmt NVarDecl  int s noinit 
		NDeclStmt NVarDecl  int w[6] init [0][2][2][6][5][4] 
		NDeclStmt NVarDecl  int v[6] init [0][6][3][5][4][6] 
		NDeclStmt NVarDecl  int x[6] noinit 
		NDeclStmt NVarDecl  int n init [5] 
		NDeclStmt NVarDecl  int C init [10] 
		NAssignStmt s = NCallExp KnapSack NIdentifierExp n NIdentifierExp w NIdentifierExp v NIdentifierExp x NIdentifierExp C
		NExpStmt NCallExp putint NIdentifierExp s
		NReturnStmt 0


This is test IR: 073_backpack.sy 


undefind global identifier


This is test: 074_matrix_add.sy 

int M;
int L;
int N;


int add(int a0[],int a1[], int a2[],int b0[],int b1[],int b2[],int c0[],int c1[],int c2[])
{
    int i;
    i=0;
    while(i<M)
    {
        c0[i]=a0[i]+b0[i];
        c1[i]=a1[i]+b1[i];
        c2[i]=a2[i]+b2[i];
        i=i+1;
    } 

    return 0;

}

int main()
{
    N=3;
    M=3;
    L=3;
    int a0[3];int a1[3]; int a2[3];int b0[3];int b1[3];int b2[3];int c0[6];int c1[3];int c2[3];
    int i;
    i=0;
    while(i<M)
    {
        a0[i]=i;
        a1[i]=i;
        a2[i]=i;
        b0[i]=i;
        b1[i]=i;
        b2[i]=i;
        i=i+1;
    }
    i=add( a0, a1,  a2, b0, b1, b2, c0, c1, c2);
    int x;
    while(i<N)
    {
        x = c0[i];
        putint(x);
        i=i+1;
    }
    x = 10;
    putch(x);
    i=0;
    while(i<N)
    {
        x = c1[i];
        putint(x);
        i=i+1;
    }
    x = 10;
    putch(x);
    i=0;
    while(i<N)
    {
        x = c2[i];
        putint(x);
        i=i+1;
    }
    x = 10;
    putch(x);

    return 0;
}


This is test AST: 074_matrix_add.sy 

NCompUnit
	NVarDecl  int M noinit
	NVarDecl  int L noinit
	NVarDecl  int N noinit
	NFuncDecl int add
		NVarDecl  int a0 noinit
		NVarDecl  int a1 noinit
		NVarDecl  int a2 noinit
		NVarDecl  int b0 noinit
		NVarDecl  int b1 noinit
		NVarDecl  int b2 noinit
		NVarDecl  int c0 noinit
		NVarDecl  int c1 noinit
		NVarDecl  int c2 noinit
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp M 
			While: NBlockStmt
			NAssignStmt c0[NIdentifierExp i] = NBinaryExp NIdentifierExp a0 NIdentifierExp i + NIdentifierExp b0 NIdentifierExp i
			NAssignStmt c1[NIdentifierExp i] = NBinaryExp NIdentifierExp a1 NIdentifierExp i + NIdentifierExp b1 NIdentifierExp i
			NAssignStmt c2[NIdentifierExp i] = NBinaryExp NIdentifierExp a2 NIdentifierExp i + NIdentifierExp b2 NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt N = 3
		NAssignStmt M = 3
		NAssignStmt L = 3
		NDeclStmt NVarDecl  int a0[3] noinit 
		NDeclStmt NVarDecl  int a1[3] noinit 
		NDeclStmt NVarDecl  int a2[3] noinit 
		NDeclStmt NVarDecl  int b0[3] noinit 
		NDeclStmt NVarDecl  int b1[3] noinit 
		NDeclStmt NVarDecl  int b2[3] noinit 
		NDeclStmt NVarDecl  int c0[6] noinit 
		NDeclStmt NVarDecl  int c1[3] noinit 
		NDeclStmt NVarDecl  int c2[3] noinit 
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp M 
			While: NBlockStmt
			NAssignStmt a0[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt a1[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt a2[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b0[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b1[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b2[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt i = NCallExp add NIdentifierExp a0 NIdentifierExp a1 NIdentifierExp a2 NIdentifierExp b0 NIdentifierExp b1 NIdentifierExp b2 NIdentifierExp c0 NIdentifierExp c1 NIdentifierExp c2
		NDeclStmt NVarDecl  int x noinit 
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp N 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c0 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NExpStmt NCallExp putch NIdentifierExp x
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp N 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c1 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NExpStmt NCallExp putch NIdentifierExp x
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp N 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c2 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NExpStmt NCallExp putch NIdentifierExp x
		NReturnStmt 0


This is test IR: 074_matrix_add.sy 


undefind global identifier


This is test: 075_matrix_sub.sy 

int N;
int M;
int L;

int sub(int a0[],int a1[], int a2[],int b0[],int b1[],int b2[],int c0[],int c1[],int c2[])
{
    int i;
    i=0;
    while(i<3)
    {
        c0[i]=a0[i]-b0[i];
        c1[i]=a1[i]-b1[i];
        c2[i]=a2[i]-b2[i];
        i=i+1;
    } 

    return 0;

}

int main()
{
    N=3;
M=3;
L=3;
    int a0[3];int a1[3]; int a2[3];int b0[3];int b1[3];int b2[3];int c0[6];int c1[3];int c2[3];
    int i;
    i=0;
    while(i<3)
    {
        a0[i]=i;
        a1[i]=i;
        a2[i]=i;
        b0[i]=i;
        b1[i]=i;
        b2[i]=i;
        i=i+1;
    }
    i=sub( a0, a1,  a2, b0, b1, b2, c0, c1, c2);
    int x;
    while(i<3)
    {
        x = c0[i];
        putint(x);
       
        i=i+1;
    }
    x = 10;
    i=0;
    putch(x);
    while(i<3)
    {
        x = c1[i];
        putint(x);
       
        i=i+1;
    }
    x = 10;
    i=0;
    putch(x);
    while(i<3)
    {
        x = c2[i];
        putint(x);
       
        i=i+1;
    }
    x =10;
    putch(x);

    return 0;
}


This is test AST: 075_matrix_sub.sy 

NCompUnit
	NVarDecl  int N noinit
	NVarDecl  int M noinit
	NVarDecl  int L noinit
	NFuncDecl int sub
		NVarDecl  int a0 noinit
		NVarDecl  int a1 noinit
		NVarDecl  int a2 noinit
		NVarDecl  int b0 noinit
		NVarDecl  int b1 noinit
		NVarDecl  int b2 noinit
		NVarDecl  int c0 noinit
		NVarDecl  int c1 noinit
		NVarDecl  int c2 noinit
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 3 
			While: NBlockStmt
			NAssignStmt c0[NIdentifierExp i] = NBinaryExp NIdentifierExp a0 NIdentifierExp i - NIdentifierExp b0 NIdentifierExp i
			NAssignStmt c1[NIdentifierExp i] = NBinaryExp NIdentifierExp a1 NIdentifierExp i - NIdentifierExp b1 NIdentifierExp i
			NAssignStmt c2[NIdentifierExp i] = NBinaryExp NIdentifierExp a2 NIdentifierExp i - NIdentifierExp b2 NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt N = 3
		NAssignStmt M = 3
		NAssignStmt L = 3
		NDeclStmt NVarDecl  int a0[3] noinit 
		NDeclStmt NVarDecl  int a1[3] noinit 
		NDeclStmt NVarDecl  int a2[3] noinit 
		NDeclStmt NVarDecl  int b0[3] noinit 
		NDeclStmt NVarDecl  int b1[3] noinit 
		NDeclStmt NVarDecl  int b2[3] noinit 
		NDeclStmt NVarDecl  int c0[6] noinit 
		NDeclStmt NVarDecl  int c1[3] noinit 
		NDeclStmt NVarDecl  int c2[3] noinit 
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 3 
			While: NBlockStmt
			NAssignStmt a0[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt a1[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt a2[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b0[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b1[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b2[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt i = NCallExp sub NIdentifierExp a0 NIdentifierExp a1 NIdentifierExp a2 NIdentifierExp b0 NIdentifierExp b1 NIdentifierExp b2 NIdentifierExp c0 NIdentifierExp c1 NIdentifierExp c2
		NDeclStmt NVarDecl  int x noinit 
		NWhileStmt NBinaryExp NIdentifierExp i < 3 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c0 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NAssignStmt i = 0
		NExpStmt NCallExp putch NIdentifierExp x
		NWhileStmt NBinaryExp NIdentifierExp i < 3 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c1 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NAssignStmt i = 0
		NExpStmt NCallExp putch NIdentifierExp x
		NWhileStmt NBinaryExp NIdentifierExp i < 3 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c2 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NExpStmt NCallExp putch NIdentifierExp x
		NReturnStmt 0


This is test IR: 075_matrix_sub.sy 


undefind global identifier


This is test: 076_matrix_mul.sy 

int M;
int L;
int N;


int mul(int a0[],int a1[], int a2[],int b0[],int b1[],int b2[],int c0[],int c1[],int c2[])
{
    int i;
    i=0;
    c0[0]=a0[0]*b0[0]+a0[1]*b1[0]+a0[2]*b2[0];
    c0[1]=a0[0]*b0[1]+a0[1]*b1[1]+a0[2]*b2[1];
    c0[2]=a0[0]*b0[2]+a0[1]*b1[2]+a0[2]*b2[2];
    c1[0]=a1[0]*b0[0]+a1[1]*b1[0]+a1[2]*b2[0];
    c1[1]=a1[0]*b0[1]+a1[1]*b1[1]+a1[2]*b2[1];
    c1[2]=a1[0]*b0[2]+a1[1]*b1[2]+a1[2]*b2[2];
    c2[0]=a2[0]*b0[0]+a2[1]*b1[0]+a2[2]*b2[0];
    c2[1]=a2[0]*b0[1]+a2[1]*b1[1]+a2[2]*b2[1];
    c2[2]=a2[0]*b0[2]+a2[1]*b1[2]+a2[2]*b2[2];

    return 0;

}

int main()
{
    N=3;
    M=3;
    L=3;
    int a0[3];int a1[3]; int a2[3];int b0[3];int b1[3];int b2[3];int c0[6];int c1[3];int c2[3];
    int i;
    i=0;
    while(i<M)
    {
        a0[i]=i;
        a1[i]=i;
        a2[i]=i;
        b0[i]=i;
        b1[i]=i;
        b2[i]=i;
        i=i+1;
    }
    i=mul( a0, a1,  a2, b0, b1, b2, c0, c1, c2);
    int x;
    while(i<N)
    {
        x = c0[i];
        putint(x);
        i=i+1;
    }
    x = 10;
    i=0;
    putch(x);
    while(i<N)
    {
        x = c1[i];
        putint(x);
       
        i=i+1;
    }
    x = 10;
    i=0;
    putch(x);
    while(i<N)
    {
        x = c2[i];
        putint(x);
       
        i=i+1;
    }
    x = 10;
    putch(x);

    return 0;
}


This is test AST: 076_matrix_mul.sy 

NCompUnit
	NVarDecl  int M noinit
	NVarDecl  int L noinit
	NVarDecl  int N noinit
	NFuncDecl int mul
		NVarDecl  int a0 noinit
		NVarDecl  int a1 noinit
		NVarDecl  int a2 noinit
		NVarDecl  int b0 noinit
		NVarDecl  int b1 noinit
		NVarDecl  int b2 noinit
		NVarDecl  int c0 noinit
		NVarDecl  int c1 noinit
		NVarDecl  int c2 noinit
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NAssignStmt c0[0] = NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a0 0 * NIdentifierExp b0 0 + NBinaryExp NIdentifierExp a0 1 * NIdentifierExp b1 0 + NBinaryExp NIdentifierExp a0 2 * NIdentifierExp b2 0
		NAssignStmt c0[1] = NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a0 0 * NIdentifierExp b0 1 + NBinaryExp NIdentifierExp a0 1 * NIdentifierExp b1 1 + NBinaryExp NIdentifierExp a0 2 * NIdentifierExp b2 1
		NAssignStmt c0[2] = NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a0 0 * NIdentifierExp b0 2 + NBinaryExp NIdentifierExp a0 1 * NIdentifierExp b1 2 + NBinaryExp NIdentifierExp a0 2 * NIdentifierExp b2 2
		NAssignStmt c1[0] = NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a1 0 * NIdentifierExp b0 0 + NBinaryExp NIdentifierExp a1 1 * NIdentifierExp b1 0 + NBinaryExp NIdentifierExp a1 2 * NIdentifierExp b2 0
		NAssignStmt c1[1] = NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a1 0 * NIdentifierExp b0 1 + NBinaryExp NIdentifierExp a1 1 * NIdentifierExp b1 1 + NBinaryExp NIdentifierExp a1 2 * NIdentifierExp b2 1
		NAssignStmt c1[2] = NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a1 0 * NIdentifierExp b0 2 + NBinaryExp NIdentifierExp a1 1 * NIdentifierExp b1 2 + NBinaryExp NIdentifierExp a1 2 * NIdentifierExp b2 2
		NAssignStmt c2[0] = NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a2 0 * NIdentifierExp b0 0 + NBinaryExp NIdentifierExp a2 1 * NIdentifierExp b1 0 + NBinaryExp NIdentifierExp a2 2 * NIdentifierExp b2 0
		NAssignStmt c2[1] = NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a2 0 * NIdentifierExp b0 1 + NBinaryExp NIdentifierExp a2 1 * NIdentifierExp b1 1 + NBinaryExp NIdentifierExp a2 2 * NIdentifierExp b2 1
		NAssignStmt c2[2] = NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a2 0 * NIdentifierExp b0 2 + NBinaryExp NIdentifierExp a2 1 * NIdentifierExp b1 2 + NBinaryExp NIdentifierExp a2 2 * NIdentifierExp b2 2
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt N = 3
		NAssignStmt M = 3
		NAssignStmt L = 3
		NDeclStmt NVarDecl  int a0[3] noinit 
		NDeclStmt NVarDecl  int a1[3] noinit 
		NDeclStmt NVarDecl  int a2[3] noinit 
		NDeclStmt NVarDecl  int b0[3] noinit 
		NDeclStmt NVarDecl  int b1[3] noinit 
		NDeclStmt NVarDecl  int b2[3] noinit 
		NDeclStmt NVarDecl  int c0[6] noinit 
		NDeclStmt NVarDecl  int c1[3] noinit 
		NDeclStmt NVarDecl  int c2[3] noinit 
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp M 
			While: NBlockStmt
			NAssignStmt a0[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt a1[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt a2[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b0[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b1[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b2[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt i = NCallExp mul NIdentifierExp a0 NIdentifierExp a1 NIdentifierExp a2 NIdentifierExp b0 NIdentifierExp b1 NIdentifierExp b2 NIdentifierExp c0 NIdentifierExp c1 NIdentifierExp c2
		NDeclStmt NVarDecl  int x noinit 
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp N 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c0 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NAssignStmt i = 0
		NExpStmt NCallExp putch NIdentifierExp x
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp N 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c1 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NAssignStmt i = 0
		NExpStmt NCallExp putch NIdentifierExp x
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp N 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c2 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NExpStmt NCallExp putch NIdentifierExp x
		NReturnStmt 0


This is test IR: 076_matrix_mul.sy 

Segmentation fault


This is test: 077_matrix_tran.sy 

int M;
int L;
int N;

int tran(int a0[],int a1[], int a2[],int b0[],int b1[],int b2[],int c0[],int c1[],int c2[])
{
    int i;
    i=0;
    c1[2]=a2[1];
    c2[1]=a1[2];
    c0[1]=a1[0];
    c0[2]=a2[0];
    c1[0]=a0[1];
    c2[0]=a0[2];
    c1[1]=a1[1];
    c2[2]=a2[2];
    c0[0]=a0[0];

    return 0;

}

int main()
{
    N=3;
    M=3;
    L=3;
    int a0[3];int a1[3]; int a2[3];int b0[3];int b1[3];int b2[3];int c0[6];int c1[3];int c2[3];
    int i;
    i=0;
    while(i<M)
    {
        a0[i]=i;
        a1[i]=i;
        a2[i]=i;
        b0[i]=i;
        b1[i]=i;
        b2[i]=i;
        i=i+1;
    }
    i=tran( a0, a1,  a2, b0, b1, b2, c0, c1, c2);
    int x;
    while(i<N)
    {
        x = c0[i];
        putint(x);
       
        i=i+1;
    }
    x = 10;
    putch(x);
    i=0;
    while(i<N)
    {
        x = c1[i];
        putint(x);
       
        i=i+1;
    }
    x = 10;
    i=0;
    putch(x);
    while(i<N)
    {
        x = c2[i];
        putint(x);
       
        i=i+1;
    }
    x = 10;
    putch(x);

    return 0;
}


This is test AST: 077_matrix_tran.sy 

NCompUnit
	NVarDecl  int M noinit
	NVarDecl  int L noinit
	NVarDecl  int N noinit
	NFuncDecl int tran
		NVarDecl  int a0 noinit
		NVarDecl  int a1 noinit
		NVarDecl  int a2 noinit
		NVarDecl  int b0 noinit
		NVarDecl  int b1 noinit
		NVarDecl  int b2 noinit
		NVarDecl  int c0 noinit
		NVarDecl  int c1 noinit
		NVarDecl  int c2 noinit
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NAssignStmt c1[2] = NIdentifierExp a2 1
		NAssignStmt c2[1] = NIdentifierExp a1 2
		NAssignStmt c0[1] = NIdentifierExp a1 0
		NAssignStmt c0[2] = NIdentifierExp a2 0
		NAssignStmt c1[0] = NIdentifierExp a0 1
		NAssignStmt c2[0] = NIdentifierExp a0 2
		NAssignStmt c1[1] = NIdentifierExp a1 1
		NAssignStmt c2[2] = NIdentifierExp a2 2
		NAssignStmt c0[0] = NIdentifierExp a0 0
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt N = 3
		NAssignStmt M = 3
		NAssignStmt L = 3
		NDeclStmt NVarDecl  int a0[3] noinit 
		NDeclStmt NVarDecl  int a1[3] noinit 
		NDeclStmt NVarDecl  int a2[3] noinit 
		NDeclStmt NVarDecl  int b0[3] noinit 
		NDeclStmt NVarDecl  int b1[3] noinit 
		NDeclStmt NVarDecl  int b2[3] noinit 
		NDeclStmt NVarDecl  int c0[6] noinit 
		NDeclStmt NVarDecl  int c1[3] noinit 
		NDeclStmt NVarDecl  int c2[3] noinit 
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp M 
			While: NBlockStmt
			NAssignStmt a0[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt a1[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt a2[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b0[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b1[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b2[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt i = NCallExp tran NIdentifierExp a0 NIdentifierExp a1 NIdentifierExp a2 NIdentifierExp b0 NIdentifierExp b1 NIdentifierExp b2 NIdentifierExp c0 NIdentifierExp c1 NIdentifierExp c2
		NDeclStmt NVarDecl  int x noinit 
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp N 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c0 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NExpStmt NCallExp putch NIdentifierExp x
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp N 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c1 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NAssignStmt i = 0
		NExpStmt NCallExp putch NIdentifierExp x
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp N 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c2 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NExpStmt NCallExp putch NIdentifierExp x
		NReturnStmt 0


This is test IR: 077_matrix_tran.sy 

Segmentation fault


This is test: 078_big_int_mul.sy 

const int len = 20;

int main()
{
	int i, j, t, n, temp;
	int mult1[len] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
	int mult2[len] = {2, 3, 4, 2, 5, 7 ,9 ,9, 0, 1, 9, 8, 7, 6, 4, 3, 2, 1, 2, 2};
	int len1 = len;
	int len2 = len;
	int c1[len + 5];
	int c2[len + 5];
	int result[len * 2] = {};

	i = 0;
	while (i < len1) {
		c1[i] = mult1[i];
		i = i + 1;
	}	

	i = 0;
	while (i < len2) {
		c2[i] = mult2[i];
		i = i + 1;
	}	

	n = len1 + len2 - 1;

	i = 0;
	while (i <= n) {
		result[i]=0;
		i = i + 1;
	}	 

	temp=0;

	i = len2 - 1;
	while (i > -1) {
		t = c2[i];
		j = len1 - 1;
		while (j > -1) {
			temp = result[n] + t * c1[j];
			if(temp >= 10) {
				result[n] = (temp);
				result[n-1] = result[n-1] + temp / 10;
			}
			else
				result[n] = temp;
			j = j - 1;
			n = n - 1;
		}
		n = n + len1 - 1;
		i = i - 1;
	}

	if(result[0] != 0)
		putint(result[0]); 

	i = 1;
	while (i <= len1 + len2 - 1) {
		putint(result[i]); 
		i = i + 1;
	}

	return 0;
}

This is test AST: 078_big_int_mul.sy 

NCompUnit
	NVarDecl const int len init [20]
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit NVarDecl  int j noinit NVarDecl  int t noinit NVarDecl  int n noinit NVarDecl  int temp noinit 
		NDeclStmt NVarDecl  int mult1[NIdentifierExp len] init [1][2][3][4][5][6][7][8][9][0][1][2][3][4][5][6][7][8][9][0] 
		NDeclStmt NVarDecl  int mult2[NIdentifierExp len] init [2][3][4][2][5][7][9][9][0][1][9][8][7][6][4][3][2][1][2][2] 
		NDeclStmt NVarDecl  int len1 init [NIdentifierExp len] 
		NDeclStmt NVarDecl  int len2 init [NIdentifierExp len] 
		NDeclStmt NVarDecl  int c1[NBinaryExp NIdentifierExp len + 5] noinit 
		NDeclStmt NVarDecl  int c2[NBinaryExp NIdentifierExp len + 5] noinit 
		NDeclStmt NVarDecl  int result[NBinaryExp NIdentifierExp len * 2] init  
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp len1 
			While: NBlockStmt
			NAssignStmt c1[NIdentifierExp i] = NIdentifierExp mult1 NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp len2 
			While: NBlockStmt
			NAssignStmt c2[NIdentifierExp i] = NIdentifierExp mult2 NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt n = NBinaryExp NBinaryExp NIdentifierExp len1 + NIdentifierExp len2 - 1
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i <= NIdentifierExp n 
			While: NBlockStmt
			NAssignStmt result[NIdentifierExp i] = 0
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt temp = 0
		NAssignStmt i = NBinaryExp NIdentifierExp len2 - 1
		NWhileStmt NBinaryExp NIdentifierExp i > NUnaryExp 277 1 
			While: NBlockStmt
			NAssignStmt t = NIdentifierExp c2 NIdentifierExp i
			NAssignStmt j = NBinaryExp NIdentifierExp len1 - 1
			NWhileStmt NBinaryExp NIdentifierExp j > NUnaryExp 277 1 
			While: NBlockStmt
			NAssignStmt temp = NBinaryExp NIdentifierExp result NIdentifierExp n + NBinaryExp NIdentifierExp t * NIdentifierExp c1 NIdentifierExp j
			NIfStmt NBinaryExp NIdentifierExp temp >= 10 
			True: NBlockStmt
			NAssignStmt result[NIdentifierExp n] = NIdentifierExp temp
			NAssignStmt result[NBinaryExp NIdentifierExp n - 1] = NBinaryExp NIdentifierExp result NBinaryExp NIdentifierExp n - 1 + NBinaryExp NIdentifierExp temp / 10
			False: NAssignStmt result[NIdentifierExp n] = NIdentifierExp temp
			NAssignStmt j = NBinaryExp NIdentifierExp j - 1
			NAssignStmt n = NBinaryExp NIdentifierExp n - 1
			NAssignStmt n = NBinaryExp NBinaryExp NIdentifierExp n + NIdentifierExp len1 - 1
			NAssignStmt i = NBinaryExp NIdentifierExp i - 1
		NIfStmt NBinaryExp NIdentifierExp result 0 != 0 
			True: NExpStmt NCallExp putint NIdentifierExp result 0
		NAssignStmt i = 1
		NWhileStmt NBinaryExp NIdentifierExp i <= NBinaryExp NBinaryExp NIdentifierExp len1 + NIdentifierExp len2 - 1 
			While: NBlockStmt
			NExpStmt NCallExp putint NIdentifierExp result NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0


This is test IR: 078_big_int_mul.sy 


undefind global identifier


This is test: 079_calculator.sy 

int ints[10000];
int intt;
int chas[10000];
int chat;
int i=0, ii=1;
int c;
int get[10000];
int get2[10000];

int isdigit(int x) {
    if (x >= 48 && x <= 57)
        return 1;
    return 0;
}

int power(int b, int a) {
    int result = 1;
    while (a != 0) {
        result = result * b;
        a = a - 1;
    }
    return result;
}

int getstr(int get[]) {
    int x = getch();
    int length = 0;
    while (x != 13 && x != 10) {
        get[length] = x;
        length = length + 1;
        x = getch();
    }
    return length;
}

void intpush(int x)
{
    intt = intt + 1;
    ints[intt] = x;
}
void chapush(int x)
{
    chat = chat + 1;
    chas[chat] = x;
}
int intpop()
{
    intt = intt - 1;
    return ints[intt + 1];
}
int chapop()
{
    chat = chat - 1;
    return chas[chat + 1];
}
void intadd(int x)
{
    ints[intt] = ints[intt] * 10;
    ints[intt] = ints[intt] + x;
}

int find()
{
    c = chapop();
    get2[ii] = 32;
    get2[ii + 1] = c;
    ii = ii + 2;
    if (chat == 0) return 0;
    return 1;
}

int main()
{
    intt=0;
    chat=0;
    int lengets = getstr(get);
    while (i < lengets)
    {
        if (isdigit(get[i]) == 1)
        {
            get2[ii] = get[i];
            ii = ii + 1;
        }
        else
        {
            if(get[i] == 40) chapush(40);
            if(get[i] == 94) chapush(94);
            if(get[i] == 41)
            {
                c = chapop();
                while (c != 40)
                {
                    get2[ii] = 32;
                    get2[ii + 1]=c;
                    ii = ii + 2;
                    c = chapop();
                }
            }
            if (get[i] == 43)
            {
                while (chas[chat] == 43 || chas[chat] == 45 || chas[chat] == 42 || chas[chat] == 47 || chas[chat] == 37 || chas[chat] == 94)
                {
                    if (find()==0)break;
                }
                chapush(43);
            }
            if (get[i] == 45)
            {
                while (chas[chat] == 43 || chas[chat] == 45 ||chas[chat] == 42 || chas[chat] == 47 || chas[chat] == 37 || chas[chat] == 94)
                {
                    if(find()==0)break;
                }
                chapush(45);
            }
            if(get[i] == 42)
            {
                while (chas[chat] == 42 || chas[chat] == 47 ||chas[chat] == 37 || chas[chat] == 94)
                {
                    if (find()==0)break;
                }
                chapush(42);
            }
            if (get[i] == 47)
            {
                while (chas[chat] == 42 || chas[chat] == 47 || chas[chat] == 37 || chas[chat] == 94)
                {
                    if (find()==0)break;
                }
                chapush(47);
            }
            if (get[i] == 37)
            {
                while (chas[chat] == 42 || chas[chat] == 47 || chas[chat] == 37 || chas[chat] == 94)
                {
                    if (find()==0)break;
                }
                chapush(37);
            }
            get2[ii] = 32;
            ii = ii + 1;
        }
        i = i + 1;
    }
    while(chat > 0)
    {
        int c = chapop();
        get2[ii] = 32;
        get2[ii + 1]=c;
        ii = ii + 2;
    }
    get2[ii]= 64;
    i = 1;
    while (get2[i] != 64)
    {
        if (get2[i] == 43 || get2[i] == 45 || get2[i] == 42 || get2[i] == 47 || get2[i] == 37 || get2[i] == 94)
        {
            int a=intpop();int b=intpop();int c;
            if (get2[i] == 43) c = a + b;
            if (get2[i] == 45) c = b - a;
            if (get2[i] == 42) c = a * b;
            if (get2[i] == 47) c = b / a;
            if (get2[i] == 37) c = b % a;
            if (get2[i] == 94) c = power(b,a);
            intpush(c);
        }
        else
        {
            if(get2[i] != 32)
            {
                intpush(get2[i] - 48);
                ii=1;
                while(get2[i+ii] != 32)
                {
                    intadd(get2[i+ii] - 48);
                    ii = ii + 1;
                }
                i = i + ii-1;
            }
        }
        i = i + 1;
    }
    putint(ints[1]);
    return 0;
}


This is test AST: 079_calculator.sy 

NCompUnit
	NVarDecl  int ints[10000] noinit
	NVarDecl  int intt noinit
	NVarDecl  int chas[10000] noinit
	NVarDecl  int chat noinit
	NVarDecl  int i init [0]
	NVarDecl  int ii init [1]
	NVarDecl  int c noinit
	NVarDecl  int get[10000] noinit
	NVarDecl  int get2[10000] noinit
	NFuncDecl int isdigit
		NVarDecl  int x noinit
		NIfStmt NBinaryExp NBinaryExp NIdentifierExp x >= 48 & NBinaryExp NIdentifierExp x <= 57 
			True: NReturnStmt 1
		NReturnStmt 0
	NFuncDecl int power
		NVarDecl  int b noinit
		NVarDecl  int a noinit
		NDeclStmt NVarDecl  int result init [1] 
		NWhileStmt NBinaryExp NIdentifierExp a != 0 
			While: NBlockStmt
			NAssignStmt result = NBinaryExp NIdentifierExp result * NIdentifierExp b
			NAssignStmt a = NBinaryExp NIdentifierExp a - 1
		NReturnStmt NIdentifierExp result
	NFuncDecl int getstr
		NVarDecl  int get noinit
		NDeclStmt NVarDecl  int x init [NCallExp getch] 
		NDeclStmt NVarDecl  int length init [0] 
		NWhileStmt NBinaryExp NBinaryExp NIdentifierExp x != 13 & NBinaryExp NIdentifierExp x != 10 
			While: NBlockStmt
			NAssignStmt get[NIdentifierExp length] = NIdentifierExp x
			NAssignStmt length = NBinaryExp NIdentifierExp length + 1
			NAssignStmt x = NCallExp getch
		NReturnStmt NIdentifierExp length
	NFuncDecl void intpush
		NVarDecl  int x noinit
		NAssignStmt intt = NBinaryExp NIdentifierExp intt + 1
		NAssignStmt ints[NIdentifierExp intt] = NIdentifierExp x
	NFuncDecl void chapush
		NVarDecl  int x noinit
		NAssignStmt chat = NBinaryExp NIdentifierExp chat + 1
		NAssignStmt chas[NIdentifierExp chat] = NIdentifierExp x
	NFuncDecl int intpop
		NAssignStmt intt = NBinaryExp NIdentifierExp intt - 1
		NReturnStmt NIdentifierExp ints NBinaryExp NIdentifierExp intt + 1
	NFuncDecl int chapop
		NAssignStmt chat = NBinaryExp NIdentifierExp chat - 1
		NReturnStmt NIdentifierExp chas NBinaryExp NIdentifierExp chat + 1
	NFuncDecl void intadd
		NVarDecl  int x noinit
		NAssignStmt ints[NIdentifierExp intt] = NBinaryExp NIdentifierExp ints NIdentifierExp intt * 10
		NAssignStmt ints[NIdentifierExp intt] = NBinaryExp NIdentifierExp ints NIdentifierExp intt + NIdentifierExp x
	NFuncDecl int find
		NAssignStmt c = NCallExp chapop
		NAssignStmt get2[NIdentifierExp ii] = 32
		NAssignStmt get2[NBinaryExp NIdentifierExp ii + 1] = NIdentifierExp c
		NAssignStmt ii = NBinaryExp NIdentifierExp ii + 2
		NIfStmt NBinaryExp NIdentifierExp chat == 0 
			True: NReturnStmt 0
		NReturnStmt 1
	NFuncDecl int main
		NAssignStmt intt = 0
		NAssignStmt chat = 0
		NDeclStmt NVarDecl  int lengets init [NCallExp getstr NIdentifierExp get] 
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp lengets 
			While: NBlockStmt
			NIfStmt NBinaryExp NCallExp isdigit NIdentifierExp get NIdentifierExp i == 1 
			True: NBlockStmt
			NAssignStmt get2[NIdentifierExp ii] = NIdentifierExp get NIdentifierExp i
			NAssignStmt ii = NBinaryExp NIdentifierExp ii + 1
			False: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp get NIdentifierExp i == 40 
			True: NExpStmt NCallExp chapush 40
			NIfStmt NBinaryExp NIdentifierExp get NIdentifierExp i == 94 
			True: NExpStmt NCallExp chapush 94
			NIfStmt NBinaryExp NIdentifierExp get NIdentifierExp i == 41 
			True: NBlockStmt
			NAssignStmt c = NCallExp chapop
			NWhileStmt NBinaryExp NIdentifierExp c != 40 
			While: NBlockStmt
			NAssignStmt get2[NIdentifierExp ii] = 32
			NAssignStmt get2[NBinaryExp NIdentifierExp ii + 1] = NIdentifierExp c
			NAssignStmt ii = NBinaryExp NIdentifierExp ii + 2
			NAssignStmt c = NCallExp chapop
			NIfStmt NBinaryExp NIdentifierExp get NIdentifierExp i == 43 
			True: NBlockStmt
			NWhileStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp chas NIdentifierExp chat == 43 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 45 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 42 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 47 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 37 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 94 
			While: NBlockStmt
			NIfStmt NBinaryExp NCallExp find == 0 
			True: NBreakStmt
			NExpStmt NCallExp chapush 43
			NIfStmt NBinaryExp NIdentifierExp get NIdentifierExp i == 45 
			True: NBlockStmt
			NWhileStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp chas NIdentifierExp chat == 43 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 45 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 42 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 47 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 37 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 94 
			While: NBlockStmt
			NIfStmt NBinaryExp NCallExp find == 0 
			True: NBreakStmt
			NExpStmt NCallExp chapush 45
			NIfStmt NBinaryExp NIdentifierExp get NIdentifierExp i == 42 
			True: NBlockStmt
			NWhileStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp chas NIdentifierExp chat == 42 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 47 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 37 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 94 
			While: NBlockStmt
			NIfStmt NBinaryExp NCallExp find == 0 
			True: NBreakStmt
			NExpStmt NCallExp chapush 42
			NIfStmt NBinaryExp NIdentifierExp get NIdentifierExp i == 47 
			True: NBlockStmt
			NWhileStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp chas NIdentifierExp chat == 42 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 47 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 37 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 94 
			While: NBlockStmt
			NIfStmt NBinaryExp NCallExp find == 0 
			True: NBreakStmt
			NExpStmt NCallExp chapush 47
			NIfStmt NBinaryExp NIdentifierExp get NIdentifierExp i == 37 
			True: NBlockStmt
			NWhileStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp chas NIdentifierExp chat == 42 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 47 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 37 | NBinaryExp NIdentifierExp chas NIdentifierExp chat == 94 
			While: NBlockStmt
			NIfStmt NBinaryExp NCallExp find == 0 
			True: NBreakStmt
			NExpStmt NCallExp chapush 37
			NAssignStmt get2[NIdentifierExp ii] = 32
			NAssignStmt ii = NBinaryExp NIdentifierExp ii + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NWhileStmt NBinaryExp NIdentifierExp chat > 0 
			While: NBlockStmt
			NDeclStmt NVarDecl  int c init [NCallExp chapop] 
			NAssignStmt get2[NIdentifierExp ii] = 32
			NAssignStmt get2[NBinaryExp NIdentifierExp ii + 1] = NIdentifierExp c
			NAssignStmt ii = NBinaryExp NIdentifierExp ii + 2
		NAssignStmt get2[NIdentifierExp ii] = 64
		NAssignStmt i = 1
		NWhileStmt NBinaryExp NIdentifierExp get2 NIdentifierExp i != 64 
			While: NBlockStmt
			NIfStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp get2 NIdentifierExp i == 43 | NBinaryExp NIdentifierExp get2 NIdentifierExp i == 45 | NBinaryExp NIdentifierExp get2 NIdentifierExp i == 42 | NBinaryExp NIdentifierExp get2 NIdentifierExp i == 47 | NBinaryExp NIdentifierExp get2 NIdentifierExp i == 37 | NBinaryExp NIdentifierExp get2 NIdentifierExp i == 94 
			True: NBlockStmt
			NDeclStmt NVarDecl  int a init [NCallExp intpop] 
			NDeclStmt NVarDecl  int b init [NCallExp intpop] 
			NDeclStmt NVarDecl  int c noinit 
			NIfStmt NBinaryExp NIdentifierExp get2 NIdentifierExp i == 43 
			True: NAssignStmt c = NBinaryExp NIdentifierExp a + NIdentifierExp b
			NIfStmt NBinaryExp NIdentifierExp get2 NIdentifierExp i == 45 
			True: NAssignStmt c = NBinaryExp NIdentifierExp b - NIdentifierExp a
			NIfStmt NBinaryExp NIdentifierExp get2 NIdentifierExp i == 42 
			True: NAssignStmt c = NBinaryExp NIdentifierExp a * NIdentifierExp b
			NIfStmt NBinaryExp NIdentifierExp get2 NIdentifierExp i == 47 
			True: NAssignStmt c = NBinaryExp NIdentifierExp b / NIdentifierExp a
			NIfStmt NBinaryExp NIdentifierExp get2 NIdentifierExp i == 37 
			True: NAssignStmt c = NBinaryExp NIdentifierExp b % NIdentifierExp a
			NIfStmt NBinaryExp NIdentifierExp get2 NIdentifierExp i == 94 
			True: NAssignStmt c = NCallExp power NIdentifierExp b NIdentifierExp a
			NExpStmt NCallExp intpush NIdentifierExp c
			False: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp get2 NIdentifierExp i != 32 
			True: NBlockStmt
			NExpStmt NCallExp intpush NBinaryExp NIdentifierExp get2 NIdentifierExp i - 48
			NAssignStmt ii = 1
			NWhileStmt NBinaryExp NIdentifierExp get2 NBinaryExp NIdentifierExp i + NIdentifierExp ii != 32 
			While: NBlockStmt
			NExpStmt NCallExp intadd NBinaryExp NIdentifierExp get2 NBinaryExp NIdentifierExp i + NIdentifierExp ii - 48
			NAssignStmt ii = NBinaryExp NIdentifierExp ii + 1
			NAssignStmt i = NBinaryExp NBinaryExp NIdentifierExp i + NIdentifierExp ii - 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NExpStmt NCallExp putint NIdentifierExp ints 1
		NReturnStmt 0


This is test IR: 079_calculator.sy 

Segmentation fault


This is test: 080_color.sy 

const int maxn = 18;
const int mod = 1000000007;
int dp[maxn][maxn][maxn][maxn][maxn][7];
int list[200];

int equal(int a, int b) {
    if (a == b)
        return 1;
    return 0;
}

int dfs(int a, int b, int c, int d, int e, int last){
    if(dp[a][b][c][d][e][last] != -1)
        return dp[a][b][c][d][e][last];
    if(a + b + c + d + e == 0)
        return 1;
    int ans = 0;
    if (a) ans = (ans + (a - equal(last, 2)) * dfs(a - 1, b, c, d, e, 1)) % mod;
    if (b) ans = (ans + (b - equal(last, 3)) * dfs(a + 1, b - 1, c, d, e, 2)) % mod;
    if (c) ans = (ans + (c - equal(last, 4)) * dfs(a, b + 1, c - 1, d, e, 3)) % mod;
    if (d) ans = (ans + (d - equal(last, 5)) * dfs(a, b, c + 1, d - 1, e, 4)) % mod;
    if (e) ans = (ans + e * dfs(a, b, c, d + 1, e - 1, 5)) % mod;
    dp[a][b][c][d][e][last] = ans % mod;
    return dp[a][b][c][d][e][last];
}

int cns[20];
 
int main(){
    int n = getint();
    int i = 0; 
    while (i < maxn) {
        int j = 0;
        while(j < maxn) {
            int k = 0;
            while(k < maxn) {
                int l = 0;
                while (l < maxn) {
                    int m = 0;
                    while (m < maxn) {
                        int h = 0;
                        while (h < 7) {
                            dp[i][j][k][l][m][h] = -1;
                            h = h + 1;
                        }
                        m = m + 1;
                    }
                    l = l + 1;
                }
                k = k + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    i = 0;
    while (i < n) {
        list[i] = getint();
        cns[list[i]] = cns[list[i]] + 1;
        i = i + 1;
    }

    int ans = dfs(cns[1], cns[2], cns[3], cns[4], cns[5], 0);

    putint(ans);

    return ans;
}

This is test AST: 080_color.sy 

NCompUnit
	NVarDecl const int maxn init [18]
	NVarDecl const int mod init [1000000007]
	NVarDecl  int dp[NIdentifierExp maxn][NIdentifierExp maxn][NIdentifierExp maxn][NIdentifierExp maxn][NIdentifierExp maxn][7] noinit
	NVarDecl  int list[200] noinit
	NFuncDecl int equal
		NVarDecl  int a noinit
		NVarDecl  int b noinit
		NIfStmt NBinaryExp NIdentifierExp a == NIdentifierExp b 
			True: NReturnStmt 1
		NReturnStmt 0
	NFuncDecl int dfs
		NVarDecl  int a noinit
		NVarDecl  int b noinit
		NVarDecl  int c noinit
		NVarDecl  int d noinit
		NVarDecl  int e noinit
		NVarDecl  int last noinit
		NIfStmt NBinaryExp NIdentifierExp dp NIdentifierExp a NIdentifierExp b NIdentifierExp c NIdentifierExp d NIdentifierExp e NIdentifierExp last != NUnaryExp 277 1 
			True: NReturnStmt NIdentifierExp dp NIdentifierExp a NIdentifierExp b NIdentifierExp c NIdentifierExp d NIdentifierExp e NIdentifierExp last
		NIfStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp a + NIdentifierExp b + NIdentifierExp c + NIdentifierExp d + NIdentifierExp e == 0 
			True: NReturnStmt 1
		NDeclStmt NVarDecl  int ans init [0] 
		NIfStmt NIdentifierExp a 
			True: NAssignStmt ans = NBinaryExp NBinaryExp NIdentifierExp ans + NBinaryExp NBinaryExp NIdentifierExp a - NCallExp equal NIdentifierExp last 2 * NCallExp dfs NBinaryExp NIdentifierExp a - 1 NIdentifierExp b NIdentifierExp c NIdentifierExp d NIdentifierExp e 1 % NIdentifierExp mod
		NIfStmt NIdentifierExp b 
			True: NAssignStmt ans = NBinaryExp NBinaryExp NIdentifierExp ans + NBinaryExp NBinaryExp NIdentifierExp b - NCallExp equal NIdentifierExp last 3 * NCallExp dfs NBinaryExp NIdentifierExp a + 1 NBinaryExp NIdentifierExp b - 1 NIdentifierExp c NIdentifierExp d NIdentifierExp e 2 % NIdentifierExp mod
		NIfStmt NIdentifierExp c 
			True: NAssignStmt ans = NBinaryExp NBinaryExp NIdentifierExp ans + NBinaryExp NBinaryExp NIdentifierExp c - NCallExp equal NIdentifierExp last 4 * NCallExp dfs NIdentifierExp a NBinaryExp NIdentifierExp b + 1 NBinaryExp NIdentifierExp c - 1 NIdentifierExp d NIdentifierExp e 3 % NIdentifierExp mod
		NIfStmt NIdentifierExp d 
			True: NAssignStmt ans = NBinaryExp NBinaryExp NIdentifierExp ans + NBinaryExp NBinaryExp NIdentifierExp d - NCallExp equal NIdentifierExp last 5 * NCallExp dfs NIdentifierExp a NIdentifierExp b NBinaryExp NIdentifierExp c + 1 NBinaryExp NIdentifierExp d - 1 NIdentifierExp e 4 % NIdentifierExp mod
		NIfStmt NIdentifierExp e 
			True: NAssignStmt ans = NBinaryExp NBinaryExp NIdentifierExp ans + NBinaryExp NIdentifierExp e * NCallExp dfs NIdentifierExp a NIdentifierExp b NIdentifierExp c NBinaryExp NIdentifierExp d + 1 NBinaryExp NIdentifierExp e - 1 5 % NIdentifierExp mod
		NAssignStmt dp[NIdentifierExp a][NIdentifierExp b][NIdentifierExp c][NIdentifierExp d][NIdentifierExp e][NIdentifierExp last] = NBinaryExp NIdentifierExp ans % NIdentifierExp mod
		NReturnStmt NIdentifierExp dp NIdentifierExp a NIdentifierExp b NIdentifierExp c NIdentifierExp d NIdentifierExp e NIdentifierExp last
	NVarDecl  int cns[20] noinit
	NFuncDecl int main
		NDeclStmt NVarDecl  int n init [NCallExp getint] 
		NDeclStmt NVarDecl  int i init [0] 
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp maxn 
			While: NBlockStmt
			NDeclStmt NVarDecl  int j init [0] 
			NWhileStmt NBinaryExp NIdentifierExp j < NIdentifierExp maxn 
			While: NBlockStmt
			NDeclStmt NVarDecl  int k init [0] 
			NWhileStmt NBinaryExp NIdentifierExp k < NIdentifierExp maxn 
			While: NBlockStmt
			NDeclStmt NVarDecl  int l init [0] 
			NWhileStmt NBinaryExp NIdentifierExp l < NIdentifierExp maxn 
			While: NBlockStmt
			NDeclStmt NVarDecl  int m init [0] 
			NWhileStmt NBinaryExp NIdentifierExp m < NIdentifierExp maxn 
			While: NBlockStmt
			NDeclStmt NVarDecl  int h init [0] 
			NWhileStmt NBinaryExp NIdentifierExp h < 7 
			While: NBlockStmt
			NAssignStmt dp[NIdentifierExp i][NIdentifierExp j][NIdentifierExp k][NIdentifierExp l][NIdentifierExp m][NIdentifierExp h] = NUnaryExp 277 1
			NAssignStmt h = NBinaryExp NIdentifierExp h + 1
			NAssignStmt m = NBinaryExp NIdentifierExp m + 1
			NAssignStmt l = NBinaryExp NIdentifierExp l + 1
			NAssignStmt k = NBinaryExp NIdentifierExp k + 1
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NAssignStmt list[NIdentifierExp i] = NCallExp getint
			NAssignStmt cns[NIdentifierExp list NIdentifierExp i] = NBinaryExp NIdentifierExp cns NIdentifierExp list NIdentifierExp i + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NDeclStmt NVarDecl  int ans init [NCallExp dfs NIdentifierExp cns 1 NIdentifierExp cns 2 NIdentifierExp cns 3 NIdentifierExp cns 4 NIdentifierExp cns 5 0] 
		NExpStmt NCallExp putint NIdentifierExp ans
		NReturnStmt NIdentifierExp ans


This is test IR: 080_color.sy 

Segmentation fault


This is test: 100_array_concat.sy 


int concat(int a0[],int b0[],int c0[])
{
    int i;
    i=0;
    while(i<3)
    {
        c0[i]=a0[i];
      
        i=i+1;
    } 
    int j;
    j=0;
    while(j<3)
    {
        c0[i]=b0[j];
        i=i+1;
        j=j+1;
    }

    return 0;

}

int main()
{
    int a0[3];int a1[3]; int a2[3];int b0[3];int b1[3];int b2[3];int c0[6];int c1[3];int c2[3];
    int i;
    i=0;
    while(i<3)
    {
        a0[i]=i;
        a1[i]=i;
        a2[i]=i;
        b0[i]=i;
        b1[i]=i;
        b2[i]=i;
        i=i+1;
    }
    i=concat( a0,b0, c0);
    int x;
    while(i<6)
    {
        x = c0[i];
        putint(x);
        i=i+1;
    }
    x = 10;
    putch(x);

    return 0;
}


This is test AST: 100_array_concat.sy 

NCompUnit
	NFuncDecl int concat
		NVarDecl  int a0 noinit
		NVarDecl  int b0 noinit
		NVarDecl  int c0 noinit
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 3 
			While: NBlockStmt
			NAssignStmt c0[NIdentifierExp i] = NIdentifierExp a0 NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NDeclStmt NVarDecl  int j noinit 
		NAssignStmt j = 0
		NWhileStmt NBinaryExp NIdentifierExp j < 3 
			While: NBlockStmt
			NAssignStmt c0[NIdentifierExp i] = NIdentifierExp b0 NIdentifierExp j
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
		NReturnStmt 0
	NFuncDecl int main
		NDeclStmt NVarDecl  int a0[3] noinit 
		NDeclStmt NVarDecl  int a1[3] noinit 
		NDeclStmt NVarDecl  int a2[3] noinit 
		NDeclStmt NVarDecl  int b0[3] noinit 
		NDeclStmt NVarDecl  int b1[3] noinit 
		NDeclStmt NVarDecl  int b2[3] noinit 
		NDeclStmt NVarDecl  int c0[6] noinit 
		NDeclStmt NVarDecl  int c1[3] noinit 
		NDeclStmt NVarDecl  int c2[3] noinit 
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 3 
			While: NBlockStmt
			NAssignStmt a0[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt a1[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt a2[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b0[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b1[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt b2[NIdentifierExp i] = NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt i = NCallExp concat NIdentifierExp a0 NIdentifierExp b0 NIdentifierExp c0
		NDeclStmt NVarDecl  int x noinit 
		NWhileStmt NBinaryExp NIdentifierExp i < 6 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp c0 NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt x = 10
		NExpStmt NCallExp putch NIdentifierExp x
		NReturnStmt 0


This is test IR: 100_array_concat.sy 


undefind global identifier


This is test: 101_insert_order.sy 

//int n;
int N;
int insert(int a[],int x)
{
    int p;
    int i;
    p=0;

    while(x>a[p]&&p<N)
        p=p+1;

    i=N;
    while(i>p)
    {
        a[i]=a[i-1];
        a[p]=x;
        i=i-1;

    }

    return 0;
}

int main()
{
    N=10;
    int a[11];
    //a[0]=1;
    a[0]=1;
    a[1]=3;
    a[2]=4;
    a[3]=7;
    a[4]=8;
    a[5]=11;
    a[6]=13;
    a[7]=18;
    a[8]=56;
    a[9]=78;
    int x;
    int i;
    i=0;
    x=getint();
    x=insert(a,x);
    //while()
    while(i<N)
    {
        x = a[i];
        putint(x);
        x= 10;
        putch(x);
        i=i+1;
    }

    return 0;
}


This is test AST: 101_insert_order.sy 

NCompUnit
	NVarDecl  int N noinit
	NFuncDecl int insert
		NVarDecl  int a noinit
		NVarDecl  int x noinit
		NDeclStmt NVarDecl  int p noinit 
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt p = 0
		NWhileStmt NBinaryExp NBinaryExp NIdentifierExp x > NIdentifierExp a NIdentifierExp p & NBinaryExp NIdentifierExp p < NIdentifierExp N 
			While: NAssignStmt p = NBinaryExp NIdentifierExp p + 1
		NAssignStmt i = NIdentifierExp N
		NWhileStmt NBinaryExp NIdentifierExp i > NIdentifierExp p 
			While: NBlockStmt
			NAssignStmt a[NIdentifierExp i] = NIdentifierExp a NBinaryExp NIdentifierExp i - 1
			NAssignStmt a[NIdentifierExp p] = NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i - 1
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt N = 10
		NDeclStmt NVarDecl  int a[11] noinit 
		NAssignStmt a[0] = 1
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 4
		NAssignStmt a[3] = 7
		NAssignStmt a[4] = 8
		NAssignStmt a[5] = 11
		NAssignStmt a[6] = 13
		NAssignStmt a[7] = 18
		NAssignStmt a[8] = 56
		NAssignStmt a[9] = 78
		NDeclStmt NVarDecl  int x noinit 
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NAssignStmt x = NCallExp getint
		NAssignStmt x = NCallExp insert NIdentifierExp a NIdentifierExp x
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp N 
			While: NBlockStmt
			NAssignStmt x = NIdentifierExp a NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp x
			NAssignStmt x = 10
			NExpStmt NCallExp putch NIdentifierExp x
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0


This is test IR: 101_insert_order.sy 


undefind global identifier


This is test: 102_line_search.sy 


int main()
{
    //newline=10;
    int i;
    int sum;
    int a[10];
    sum=0;
    //m = 1478;
    //int t;
    i=0;
    while(i<10)
    {
        a[i]=i+1;
        i=i+1;
    }
    int x;
    int high;
    int low;
    int mid;
    int n;
    n=10;
    x=getint();
    high=n-1;
    low=0;
    mid=(high+low)/2;
    int flag;
    flag=0;
    //int i;
    i=0;
    int j;
    j=0;
    while(i<10 && flag==0)
    {
        if(a[i]==x)
        {
            flag=1;
            j=i;
        }
        
        i=i+1;
       
    }

     if(flag==1)
        putint(j);
        else
        {
            x = 0;
            putint(x);
        }
        


    x= 10;
    putch(x);

    return 0;
}


This is test AST: 102_line_search.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int sum noinit 
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt sum = 0
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 10 
			While: NBlockStmt
			NAssignStmt a[NIdentifierExp i] = NBinaryExp NIdentifierExp i + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NDeclStmt NVarDecl  int x noinit 
		NDeclStmt NVarDecl  int high noinit 
		NDeclStmt NVarDecl  int low noinit 
		NDeclStmt NVarDecl  int mid noinit 
		NDeclStmt NVarDecl  int n noinit 
		NAssignStmt n = 10
		NAssignStmt x = NCallExp getint
		NAssignStmt high = NBinaryExp NIdentifierExp n - 1
		NAssignStmt low = 0
		NAssignStmt mid = NBinaryExp NBinaryExp NIdentifierExp high + NIdentifierExp low / 2
		NDeclStmt NVarDecl  int flag noinit 
		NAssignStmt flag = 0
		NAssignStmt i = 0
		NDeclStmt NVarDecl  int j noinit 
		NAssignStmt j = 0
		NWhileStmt NBinaryExp NBinaryExp NIdentifierExp i < 10 & NBinaryExp NIdentifierExp flag == 0 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp a NIdentifierExp i == NIdentifierExp x 
			True: NBlockStmt
			NAssignStmt flag = 1
			NAssignStmt j = NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NIfStmt NBinaryExp NIdentifierExp flag == 1 
			True: NExpStmt NCallExp putint NIdentifierExp j
			False: NBlockStmt
			NAssignStmt x = 0
			NExpStmt NCallExp putint NIdentifierExp x
		NAssignStmt x = 10
		NExpStmt NCallExp putch NIdentifierExp x
		NReturnStmt 0


This is test IR: 102_line_search.sy 


undefind global identifier


This is test: 81_go_upstairs.sy 

int climbStairs(int n) {
    if(n < 4)
        return n;
    int dp[10];
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    int i;
    i = 3;
    while(i<n+1){
        dp[i] = dp[i-1] + dp[i-2];
        i = i + 1;
    }
    return dp[n];
}
int main(){
    int res;
    int n;
    n=5;
    res = climbStairs(n);
    return res;
}

This is test AST: 81_go_upstairs.sy 

NCompUnit
	NFuncDecl int climbStairs
		NVarDecl  int n noinit
		NIfStmt NBinaryExp NIdentifierExp n < 4 
			True: NReturnStmt NIdentifierExp n
		NDeclStmt NVarDecl  int dp[10] noinit 
		NAssignStmt dp[0] = 0
		NAssignStmt dp[1] = 1
		NAssignStmt dp[2] = 2
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 3
		NWhileStmt NBinaryExp NIdentifierExp i < NBinaryExp NIdentifierExp n + 1 
			While: NBlockStmt
			NAssignStmt dp[NIdentifierExp i] = NBinaryExp NIdentifierExp dp NBinaryExp NIdentifierExp i - 1 + NIdentifierExp dp NBinaryExp NIdentifierExp i - 2
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt NIdentifierExp dp NIdentifierExp n
	NFuncDecl int main
		NDeclStmt NVarDecl  int res noinit 
		NDeclStmt NVarDecl  int n noinit 
		NAssignStmt n = 5
		NAssignStmt res = NCallExp climbStairs NIdentifierExp n
		NReturnStmt NIdentifierExp res


This is test IR: 81_go_upstairs.sy 

Segmentation fault


This is test: 82_remove_duplicate_element.sy 

int removeElement(int nums[], int n, int val) {
    int i;
    i = 0;
    while (i < n) {
        if (nums[i] == val) {
            nums[i] = nums[n - 1];
            n = n - 1;
        } else {
            i = i + 1;
        }
    }
    return n;
}    
int main(){
    int res;
    int a[10];
    a[0]=3;a[1]=3;a[2]=9;a[3]=0;a[4]=0;
    a[5]=1;a[6]=1;a[7]=5;a[8]=7;a[9]=8;
    res = 10;
    int val;
    val = 3;
    res = removeElement(a, res, val);
    return res;
}

This is test AST: 82_remove_duplicate_element.sy 

NCompUnit
	NFuncDecl int removeElement
		NVarDecl  int nums noinit
		NVarDecl  int n noinit
		NVarDecl  int val noinit
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp nums NIdentifierExp i == NIdentifierExp val 
			True: NBlockStmt
			NAssignStmt nums[NIdentifierExp i] = NIdentifierExp nums NBinaryExp NIdentifierExp n - 1
			NAssignStmt n = NBinaryExp NIdentifierExp n - 1
			False: NBlockStmt
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt NIdentifierExp n
	NFuncDecl int main
		NDeclStmt NVarDecl  int res noinit 
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = 3
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = 0
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = 1
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NAssignStmt res = 10
		NDeclStmt NVarDecl  int val noinit 
		NAssignStmt val = 3
		NAssignStmt res = NCallExp removeElement NIdentifierExp a NIdentifierExp res NIdentifierExp val
		NReturnStmt NIdentifierExp res


This is test IR: 82_remove_duplicate_element.sy 


undefind global identifier


This is test: 83_accumulate.sy 


int main()
{
    //newline=10;
    int i;
    int sum;
    sum=0;
    //m = 1478;
    //int t;
    i=0;
    while(i<21)
    {
        sum=sum+i;
        i=i+1;
    }
    
    putint(sum);

    return 0;
}

This is test AST: 83_accumulate.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int sum noinit 
		NAssignStmt sum = 0
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 21 
			While: NBlockStmt
			NAssignStmt sum = NBinaryExp NIdentifierExp sum + NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NExpStmt NCallExp putint NIdentifierExp sum
		NReturnStmt 0


This is test IR: 83_accumulate.sy 

Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 6
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:0	int: 1		
		Store argNum:2 int:0	int: 0		
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 1			
Instruction: 		Load argNum:1 int: 0				int: 1		
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			int:1		int: 0		
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		



This is test: 84_last_word_length.sy 

int lengthOfLastWord(int s[], int n) {
    if(n == 0)
        return 0;
    int c;
    c = n - 1;
    while(c > -1 && s[c] == 0){
        c = c - 1;
    }
    if(c == -1)
        return 0;
    int i;
    i = c; 
    while(i > -1){
        if(s[i] == 0)
            return n - i - 1 - (n - 1 - c);
        i = i - 1;
    }
    return c - i;
}
int main(){
    int res;
    int a[10];
    a[0]=-4;a[1]=3;a[2]=9;a[3]=-2;a[4]=0;
    a[5]=1;a[6]=-6;a[7]=5;a[8]=7;a[9]=8;
    res = 10;
    res = lengthOfLastWord(a, res);
    return res;
}

This is test AST: 84_last_word_length.sy 

NCompUnit
	NFuncDecl int lengthOfLastWord
		NVarDecl  int s noinit
		NVarDecl  int n noinit
		NIfStmt NBinaryExp NIdentifierExp n == 0 
			True: NReturnStmt 0
		NDeclStmt NVarDecl  int c noinit 
		NAssignStmt c = NBinaryExp NIdentifierExp n - 1
		NWhileStmt NBinaryExp NBinaryExp NIdentifierExp c > NUnaryExp 277 1 & NBinaryExp NIdentifierExp s NIdentifierExp c == 0 
			While: NBlockStmt
			NAssignStmt c = NBinaryExp NIdentifierExp c - 1
		NIfStmt NBinaryExp NIdentifierExp c == NUnaryExp 277 1 
			True: NReturnStmt 0
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = NIdentifierExp c
		NWhileStmt NBinaryExp NIdentifierExp i > NUnaryExp 277 1 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp s NIdentifierExp i == 0 
			True: NReturnStmt NBinaryExp NBinaryExp NBinaryExp NIdentifierExp n - NIdentifierExp i - 1 - NBinaryExp NBinaryExp NIdentifierExp n - 1 - NIdentifierExp c
			NAssignStmt i = NBinaryExp NIdentifierExp i - 1
		NReturnStmt NBinaryExp NIdentifierExp c - NIdentifierExp i
	NFuncDecl int main
		NDeclStmt NVarDecl  int res noinit 
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = NUnaryExp 277 4
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = NUnaryExp 277 2
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = NUnaryExp 277 6
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NAssignStmt res = 10
		NAssignStmt res = NCallExp lengthOfLastWord NIdentifierExp a NIdentifierExp res
		NReturnStmt NIdentifierExp res


This is test IR: 84_last_word_length.sy 

Segmentation fault


This is test: 85_multi.sy 

int main()
{
    //newline=10;
    int i;
    int sum;
    sum=0;
    //m = 1478;
    //int t;
    i=0;
    while(i<21)
    {
        sum=sum*i;
        i=i+1;
    }
    
    putint(sum);

    return 0;
}


This is test AST: 85_multi.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int sum noinit 
		NAssignStmt sum = 0
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 21 
			While: NBlockStmt
			NAssignStmt sum = NBinaryExp NIdentifierExp sum * NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NExpStmt NCallExp putint NIdentifierExp sum
		NReturnStmt 0


This is test IR: 85_multi.sy 

Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 6
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 int:0	int: 1		
		Store argNum:2 int:0	int: 0		
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Mul argNum:2 
Instruction: 		Load argNum:1 int: 1			
Instruction: 		Load argNum:1 int: 0				int: 1		
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			int:1		int: 0		
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		



This is test: 86_max_subsequence_sum.sy 

int maxSubArray(int nums[], int n) {
    if(n == 0)
        return 0;
    if(n == 1)
        return nums[0];
    int sum;
    sum = nums[0];
    int max;
    max = sum;
    int i;
    i = 1;
    while(i < n){
        if(sum < 0)
            sum = 0;
        sum = sum + nums[i];
        if(max < sum)
            max = sum;
        i = i + 1;
    }
    return max;
}
int main(){
    int res;
    int a[10];
    a[0]=-4;a[1]=3;a[2]=9;a[3]=-2;a[4]=0;
    a[5]=1;a[6]=-6;a[7]=5;a[8]=7;a[9]=8;
    res = 10;
    res = maxSubArray(a, res);
    return res;
}

This is test AST: 86_max_subsequence_sum.sy 

NCompUnit
	NFuncDecl int maxSubArray
		NVarDecl  int nums noinit
		NVarDecl  int n noinit
		NIfStmt NBinaryExp NIdentifierExp n == 0 
			True: NReturnStmt 0
		NIfStmt NBinaryExp NIdentifierExp n == 1 
			True: NReturnStmt NIdentifierExp nums 0
		NDeclStmt NVarDecl  int sum noinit 
		NAssignStmt sum = NIdentifierExp nums 0
		NDeclStmt NVarDecl  int max noinit 
		NAssignStmt max = NIdentifierExp sum
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 1
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp sum < 0 
			True: NAssignStmt sum = 0
			NAssignStmt sum = NBinaryExp NIdentifierExp sum + NIdentifierExp nums NIdentifierExp i
			NIfStmt NBinaryExp NIdentifierExp max < NIdentifierExp sum 
			True: NAssignStmt max = NIdentifierExp sum
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt NIdentifierExp max
	NFuncDecl int main
		NDeclStmt NVarDecl  int res noinit 
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = NUnaryExp 277 4
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = NUnaryExp 277 2
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = NUnaryExp 277 6
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NAssignStmt res = 10
		NAssignStmt res = NCallExp maxSubArray NIdentifierExp a NIdentifierExp res
		NReturnStmt NIdentifierExp res


This is test IR: 86_max_subsequence_sum.sy 

Segmentation fault


This is test: 87_enum.sy 

int main()
{
    int i;
    int j;
    int k;
    int t;
    i=0;j=0;k=0;
    while(i<21)
    {
        while(j<101-i)
        {
            k=100-i-j;
            if(5*i+1*j+k/2==100)
            {
                putint(i);
                putint(j);
                putint(k);
                t=10;
                putch(t);
            }
            j=j+1;
        }
        i=i+1;
    }

    return 0;
}


This is test AST: 87_enum.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int j noinit 
		NDeclStmt NVarDecl  int k noinit 
		NDeclStmt NVarDecl  int t noinit 
		NAssignStmt i = 0
		NAssignStmt j = 0
		NAssignStmt k = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 21 
			While: NBlockStmt
			NWhileStmt NBinaryExp NIdentifierExp j < NBinaryExp 101 - NIdentifierExp i 
			While: NBlockStmt
			NAssignStmt k = NBinaryExp NBinaryExp 100 - NIdentifierExp i - NIdentifierExp j
			NIfStmt NBinaryExp NBinaryExp NBinaryExp NBinaryExp 5 * NIdentifierExp i + NBinaryExp 1 * NIdentifierExp j + NBinaryExp NIdentifierExp k / 2 == 100 
			True: NBlockStmt
			NExpStmt NCallExp putint NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp j
			NExpStmt NCallExp putint NIdentifierExp k
			NAssignStmt t = 10
			NExpStmt NCallExp putch NIdentifierExp t
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0


This is test IR: 87_enum.sy 

Function: main entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 11
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Store argNum:2 int:0	int: 0		
		Store argNum:2 int:0	int: 1		
		Store argNum:2 int:0	int: 2		
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Sub argNum:2 int:100	
Instruction: 		Load argNum:1 int: 0				
Instruction: 		Load argNum:1 int: 1				int: 2		
		Br argNum:2 
Instruction: 		EQ argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Mul argNum:2 int:5	
Instruction: 		Load argNum:1 int: 0				
Instruction: 		Mul argNum:2 int:1	
Instruction: 		Load argNum:1 int: 1					
Instruction: 		Div argNum:2 
Instruction: 		Load argNum:1 int: 2			int:2			int:100		Block or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 int:10	int: 3		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 1			int:1		int: 1		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			int:1		int: 0		
    BlockType 0 InstructionListLength = 1
		constant argNum:1 int: 0		



This is test: 88_exchange_value.sy 

int n;

int main()
{
    //newline=10;
    int i;
    int j;
    //m = 1478;
    //int t;
    i=getint();
    j=getint();
    int temp;
    temp=i;
    i=j;
    j=temp;

    putint(i);
    temp = 10;
    putch(temp);
    putint(j);
    temp = 10;
    putch(temp);
    
    return 0;
}


This is test AST: 88_exchange_value.sy 

NCompUnit
	NVarDecl  int n noinit
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int j noinit 
		NAssignStmt i = NCallExp getint
		NAssignStmt j = NCallExp getint
		NDeclStmt NVarDecl  int temp noinit 
		NAssignStmt temp = NIdentifierExp i
		NAssignStmt i = NIdentifierExp j
		NAssignStmt j = NIdentifierExp temp
		NExpStmt NCallExp putint NIdentifierExp i
		NAssignStmt temp = 10
		NExpStmt NCallExp putch NIdentifierExp temp
		NExpStmt NCallExp putint NIdentifierExp j
		NAssignStmt temp = 10
		NExpStmt NCallExp putch NIdentifierExp temp
		NReturnStmt 0


This is test IR: 88_exchange_value.sy 

n
int: n
Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 14
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Store argNum:2 
Segmentation fault


This is test: 89_itera_sqrt.sy 

int fsqrt(int a)
{
    int x0=0;
    int x1;
    x1=a/2;
    while(x0-x1!=0)
    {
        x0=x1;
        x1=(x0+a/x0);
        x1=x1/2;
    }

    return x1;

}

int main()
{
    int a;
    a=400;
    int res;
    res=fsqrt(a);
    putint(res);
    res = 10;
    putch(res);
    return 0;
}


This is test AST: 89_itera_sqrt.sy 

NCompUnit
	NFuncDecl int fsqrt
		NVarDecl  int a noinit
		NDeclStmt NVarDecl  int x0 init [0] 
		NDeclStmt NVarDecl  int x1 noinit 
		NAssignStmt x1 = NBinaryExp NIdentifierExp a / 2
		NWhileStmt NBinaryExp NBinaryExp NIdentifierExp x0 - NIdentifierExp x1 != 0 
			While: NBlockStmt
			NAssignStmt x0 = NIdentifierExp x1
			NAssignStmt x1 = NBinaryExp NIdentifierExp x0 + NBinaryExp NIdentifierExp a / NIdentifierExp x0
			NAssignStmt x1 = NBinaryExp NIdentifierExp x1 / 2
		NReturnStmt NIdentifierExp x1
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 400
		NDeclStmt NVarDecl  int res noinit 
		NAssignStmt res = NCallExp fsqrt NIdentifierExp a
		NExpStmt NCallExp putint NIdentifierExp res
		NAssignStmt res = 10
		NExpStmt NCallExp putch NIdentifierExp res
		NReturnStmt 0


This is test IR: 89_itera_sqrt.sy 

Function: fsqrt entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 5
		Alloca argNum:0 
		Store argNum:2 int:0	int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 
Instruction: 		Div argNum:2 
Instruction: 		Load argNum:1 int: -1621514704			int:2		int: 1		
    BlockType 0 InstructionListLength = 3
		Store argNum:2 
Instruction: 		Load argNum:1 int: 1			int: 0		
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 0			
Instruction: 		Div argNum:2 
Instruction: 		Load argNum:1 int: -1621514704			
Instruction: 		Load argNum:1 int: 0					int: 1		
		Store argNum:2 
Instruction: 		Div argNum:2 
Instruction: 		Load argNum:1 int: 1			int:2		int: 1		
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 1		

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 8
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Store argNum:2 int:400	int: 2		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Store argNum:2 
Instruction: 		Call argNum:2 
Instruction: 		Load argNum:1 int: 2			Block or something	int: 3		
		Store argNum:2 int:10	int: 3		
		constant argNum:1 int: 0		



This is test: 90_max_container.sy 

int maxArea(int height[], int n) {
    int i;
    int j;
    i = 0;
    j = n - 1;
    int max_val;
    max_val = -1;
    while(i < j){
        int area;
        if(height[i] < height[j])
            area = (j - i) * height[i];
        else
            area = (j - i) * height[j];
        if(area > max_val){
            max_val = area;
        }
        if(height[i] > height[j])
            j = j - 1;
        else
            i = i + 1;
    }
    return max_val;
}

int main(){
    int res;
    int a[10];
    a[0]=3;a[1]=3;a[2]=9;a[3]=0;a[4]=0;
    a[5]=1;a[6]=1;a[7]=5;a[8]=7;a[9]=8;
    res = 10;
    res = maxArea(a, res);
    return res;
}

This is test AST: 90_max_container.sy 

NCompUnit
	NFuncDecl int maxArea
		NVarDecl  int height noinit
		NVarDecl  int n noinit
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int j noinit 
		NAssignStmt i = 0
		NAssignStmt j = NBinaryExp NIdentifierExp n - 1
		NDeclStmt NVarDecl  int max_val noinit 
		NAssignStmt max_val = NUnaryExp 277 1
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp j 
			While: NBlockStmt
			NDeclStmt NVarDecl  int area noinit 
			NIfStmt NBinaryExp NIdentifierExp height NIdentifierExp i < NIdentifierExp height NIdentifierExp j 
			True: NAssignStmt area = NBinaryExp NBinaryExp NIdentifierExp j - NIdentifierExp i * NIdentifierExp height NIdentifierExp i
			False: NAssignStmt area = NBinaryExp NBinaryExp NIdentifierExp j - NIdentifierExp i * NIdentifierExp height NIdentifierExp j
			NIfStmt NBinaryExp NIdentifierExp area > NIdentifierExp max_val 
			True: NBlockStmt
			NAssignStmt max_val = NIdentifierExp area
			NIfStmt NBinaryExp NIdentifierExp height NIdentifierExp i > NIdentifierExp height NIdentifierExp j 
			True: NAssignStmt j = NBinaryExp NIdentifierExp j - 1
			False: NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt NIdentifierExp max_val
	NFuncDecl int main
		NDeclStmt NVarDecl  int res noinit 
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = 3
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = 0
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = 1
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NAssignStmt res = 10
		NAssignStmt res = NCallExp maxArea NIdentifierExp a NIdentifierExp res
		NReturnStmt NIdentifierExp res


This is test IR: 90_max_container.sy 


undefind global identifier


This is test: 91_int_factor_sum.sy 

int N;

int newline;

int factor(int n )
{
    int i;
    int sum;
    sum=0;
    i=1;
    while(i<n+1)
    {
        if(n%i == 0)
        {
            sum=sum+i;
        }
        i=i+1;
    }

    return sum;
}

int main()
{
    N=4;
    newline=10;
    int i;
    int m;
    m = 1478;
    int t;
    
    return factor(m);
}

This is test AST: 91_int_factor_sum.sy 

NCompUnit
	NVarDecl  int N noinit
	NVarDecl  int newline noinit
	NFuncDecl int factor
		NVarDecl  int n noinit
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int sum noinit 
		NAssignStmt sum = 0
		NAssignStmt i = 1
		NWhileStmt NBinaryExp NIdentifierExp i < NBinaryExp NIdentifierExp n + 1 
			While: NBlockStmt
			NIfStmt NBinaryExp NBinaryExp NIdentifierExp n % NIdentifierExp i == 0 
			True: NBlockStmt
			NAssignStmt sum = NBinaryExp NIdentifierExp sum + NIdentifierExp i
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt NIdentifierExp sum
	NFuncDecl int main
		NAssignStmt N = 4
		NAssignStmt newline = 10
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int m noinit 
		NAssignStmt m = 1478
		NDeclStmt NVarDecl  int t noinit 
		NReturnStmt NCallExp factor NIdentifierExp m


This is test IR: 91_int_factor_sum.sy 

N
int: N
newline
int: newline
Function: factor entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 7
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Store argNum:2 int:0	int: 3		
		Store argNum:2 int:1	int: 2		
		Br argNum:2 
Instruction: 		EQ argNum:2 
terminate called after throwing an instance of 'std::out_of_range'
  what():  map::at
Aborted


This is test: 92_unique_path.sy 

int uniquePaths(int m, int n) {
    if(m == 1 || n == 1)
        return 1;

    int dp[9];
    int i;
    int j;
    i = 0;
    while(i<m){
        dp[i*3+n-1]=1;
        i = i + 1;
    }
    i = 0;
    while(i<n){
        dp[(m-1)*3+i]=1;
        i = i + 1;
    }
    i=m-2;
    while(i > -1){
        j=n-2;
        while(j > -1){
            dp[i*3+j] = dp[(i+1)*3+j] + dp[i*3+j+1];
            j = j - 1;
        }
        i = i - 1;
    }
    return dp[0];
}
int main(){
    int res;
    int n;
    n=3;
    res = uniquePaths(n, n);
    return res;
}

This is test AST: 92_unique_path.sy 

NCompUnit
	NFuncDecl int uniquePaths
		NVarDecl  int m noinit
		NVarDecl  int n noinit
		NIfStmt NBinaryExp NBinaryExp NIdentifierExp m == 1 | NBinaryExp NIdentifierExp n == 1 
			True: NReturnStmt 1
		NDeclStmt NVarDecl  int dp[9] noinit 
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int j noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp m 
			While: NBlockStmt
			NAssignStmt dp[NBinaryExp NBinaryExp NBinaryExp NIdentifierExp i * 3 + NIdentifierExp n - 1] = 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NIdentifierExp n 
			While: NBlockStmt
			NAssignStmt dp[NBinaryExp NBinaryExp NBinaryExp NIdentifierExp m - 1 * 3 + NIdentifierExp i] = 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt i = NBinaryExp NIdentifierExp m - 2
		NWhileStmt NBinaryExp NIdentifierExp i > NUnaryExp 277 1 
			While: NBlockStmt
			NAssignStmt j = NBinaryExp NIdentifierExp n - 2
			NWhileStmt NBinaryExp NIdentifierExp j > NUnaryExp 277 1 
			While: NBlockStmt
			NAssignStmt dp[NBinaryExp NBinaryExp NIdentifierExp i * 3 + NIdentifierExp j] = NBinaryExp NIdentifierExp dp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp i + 1 * 3 + NIdentifierExp j + NIdentifierExp dp NBinaryExp NBinaryExp NBinaryExp NIdentifierExp i * 3 + NIdentifierExp j + 1
			NAssignStmt j = NBinaryExp NIdentifierExp j - 1
			NAssignStmt i = NBinaryExp NIdentifierExp i - 1
		NReturnStmt NIdentifierExp dp 0
	NFuncDecl int main
		NDeclStmt NVarDecl  int res noinit 
		NDeclStmt NVarDecl  int n noinit 
		NAssignStmt n = 3
		NAssignStmt res = NCallExp uniquePaths NIdentifierExp n NIdentifierExp n
		NReturnStmt NIdentifierExp res


This is test IR: 92_unique_path.sy 

Segmentation fault


This is test: 93_decbinoct.sy 

int dec2bin(int a)
{
    int res;
    int k;
    int i;
    int temp;
    res=0;
    k=1;
    temp=a;
    while(temp!=0)
    {
        i=temp%2;
        res=k*i+res;
        k=k*10;
        temp=temp/2;
    }
   return res;

}

int main()
{
    int a;
    a=400;
    int res;
    res=dec2bin(a);
    putint(res);
    res = 10;
    putch(res);
    return 0;
}


This is test AST: 93_decbinoct.sy 

NCompUnit
	NFuncDecl int dec2bin
		NVarDecl  int a noinit
		NDeclStmt NVarDecl  int res noinit 
		NDeclStmt NVarDecl  int k noinit 
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int temp noinit 
		NAssignStmt res = 0
		NAssignStmt k = 1
		NAssignStmt temp = NIdentifierExp a
		NWhileStmt NBinaryExp NIdentifierExp temp != 0 
			While: NBlockStmt
			NAssignStmt i = NBinaryExp NIdentifierExp temp % 2
			NAssignStmt res = NBinaryExp NBinaryExp NIdentifierExp k * NIdentifierExp i + NIdentifierExp res
			NAssignStmt k = NBinaryExp NIdentifierExp k * 10
			NAssignStmt temp = NBinaryExp NIdentifierExp temp / 2
		NReturnStmt NIdentifierExp res
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 400
		NDeclStmt NVarDecl  int res noinit 
		NAssignStmt res = NCallExp dec2bin NIdentifierExp a
		NExpStmt NCallExp putint NIdentifierExp res
		NAssignStmt res = 10
		NExpStmt NCallExp putch NIdentifierExp res
		NReturnStmt 0


This is test IR: 93_decbinoct.sy 

Function: dec2bin entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 11
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Store argNum:2 int:0	int: 0		
		Store argNum:2 int:1	int: 1		
		Store argNum:2 
Instruction: 		Load argNum:1 int: -830237136			int: 3		
    BlockType 0 InstructionListLength = 4
		Store argNum:2 
terminate called after throwing an instance of 'std::out_of_range'
  what():  map::at
Aborted


This is test: 94_lcm.sy 

int n;

int gcd(int m,int n)
{ 
    int a;
    int b;
    a=m;
    b=n;

    int t;
    int r;

    if(m<n) { t=m;m=n;n=t; }

    r=m%n;

    while(r!=0)

    {m=n;   n=r;   r=m%n;  }

   return (a*b)/n;
}

int main()
{
    //newline=10;
    int i;
    int m;
    //m = 1478;
    //int t;
    i=getint();
    m=getint();
    
    return gcd(i,m);
}

This is test AST: 94_lcm.sy 

NCompUnit
	NVarDecl  int n noinit
	NFuncDecl int gcd
		NVarDecl  int m noinit
		NVarDecl  int n noinit
		NDeclStmt NVarDecl  int a noinit 
		NDeclStmt NVarDecl  int b noinit 
		NAssignStmt a = NIdentifierExp m
		NAssignStmt b = NIdentifierExp n
		NDeclStmt NVarDecl  int t noinit 
		NDeclStmt NVarDecl  int r noinit 
		NIfStmt NBinaryExp NIdentifierExp m < NIdentifierExp n 
			True: NBlockStmt
			NAssignStmt t = NIdentifierExp m
			NAssignStmt m = NIdentifierExp n
			NAssignStmt n = NIdentifierExp t
		NAssignStmt r = NBinaryExp NIdentifierExp m % NIdentifierExp n
		NWhileStmt NBinaryExp NIdentifierExp r != 0 
			While: NBlockStmt
			NAssignStmt m = NIdentifierExp n
			NAssignStmt n = NIdentifierExp r
			NAssignStmt r = NBinaryExp NIdentifierExp m % NIdentifierExp n
		NReturnStmt NBinaryExp NBinaryExp NIdentifierExp a * NIdentifierExp b / NIdentifierExp n
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int m noinit 
		NAssignStmt i = NCallExp getint
		NAssignStmt m = NCallExp getint
		NReturnStmt NCallExp gcd NIdentifierExp i NIdentifierExp m


This is test IR: 94_lcm.sy 

n
int: n
Function: gcd entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 11
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 2		
		Store argNum:2 
Instruction: 		Load argNum:1 int: 768624176			int: 1		
		Store argNum:2 
Instruction: 		Load argNum:1 int: 768624176			int: 2		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 3		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 4		
		Br argNum:2 
Instruction: 		LT argNum:2 
Instruction: 		Load argNum:1 int: 768624176			
Instruction: 		Load argNum:1 int: 768624176				Block or something
    BlockType 0 InstructionListLength = 3
		Store argNum:2 
Instruction: 		Load argNum:1 int: 768624176			int: 3		
		Store argNum:2 
Instruction: 		Load argNum:1 int: 768624176			int: 768624176		
		Store argNum:2 
Instruction: 		Load argNum:1 int: 3			int: 768624176		
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
terminate called after throwing an instance of 'std::out_of_range'
  what():  map::at
Aborted


This is test: 95_jump_game.sy 

int canJump(int nums[], int n) {
    if(n == 1)
        return 1;
    if(nums[0] > n - 2)
        return 1;
    int dp[10];
    int i;
    i = 0;
    while(i<n-1){
        dp[i] = 0;
        i = i +1;
    }
    dp[n - 1] = 1;
    i = n - 2;
    while(i > -1){
        int j;
        if(nums[i] < n - 1 - i){
            j = nums[i];
        }
        else
            j = n - 1 - i;
        while(j > -1){
            if(dp[i+j] != 0){
                dp[i] = 1;
            }
            j = j - 1;
        }
        i = i - 1;
    }

    return dp[0];
}
int main(){
    int res;
    int a[10];
    a[0]=3;a[1]=3;a[2]=9;a[3]=0;a[4]=0;
    a[5]=1;a[6]=1;a[7]=5;a[8]=7;a[9]=8;
    res = 10;
    res = canJump(a, res);
    return res;
}

This is test AST: 95_jump_game.sy 

NCompUnit
	NFuncDecl int canJump
		NVarDecl  int nums noinit
		NVarDecl  int n noinit
		NIfStmt NBinaryExp NIdentifierExp n == 1 
			True: NReturnStmt 1
		NIfStmt NBinaryExp NIdentifierExp nums 0 > NBinaryExp NIdentifierExp n - 2 
			True: NReturnStmt 1
		NDeclStmt NVarDecl  int dp[10] noinit 
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < NBinaryExp NIdentifierExp n - 1 
			While: NBlockStmt
			NAssignStmt dp[NIdentifierExp i] = 0
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NAssignStmt dp[NBinaryExp NIdentifierExp n - 1] = 1
		NAssignStmt i = NBinaryExp NIdentifierExp n - 2
		NWhileStmt NBinaryExp NIdentifierExp i > NUnaryExp 277 1 
			While: NBlockStmt
			NDeclStmt NVarDecl  int j noinit 
			NIfStmt NBinaryExp NIdentifierExp nums NIdentifierExp i < NBinaryExp NBinaryExp NIdentifierExp n - 1 - NIdentifierExp i 
			True: NBlockStmt
			NAssignStmt j = NIdentifierExp nums NIdentifierExp i
			False: NAssignStmt j = NBinaryExp NBinaryExp NIdentifierExp n - 1 - NIdentifierExp i
			NWhileStmt NBinaryExp NIdentifierExp j > NUnaryExp 277 1 
			While: NBlockStmt
			NIfStmt NBinaryExp NIdentifierExp dp NBinaryExp NIdentifierExp i + NIdentifierExp j != 0 
			True: NBlockStmt
			NAssignStmt dp[NIdentifierExp i] = 1
			NAssignStmt j = NBinaryExp NIdentifierExp j - 1
			NAssignStmt i = NBinaryExp NIdentifierExp i - 1
		NReturnStmt NIdentifierExp dp 0
	NFuncDecl int main
		NDeclStmt NVarDecl  int res noinit 
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt a[0] = 3
		NAssignStmt a[1] = 3
		NAssignStmt a[2] = 9
		NAssignStmt a[3] = 0
		NAssignStmt a[4] = 0
		NAssignStmt a[5] = 1
		NAssignStmt a[6] = 1
		NAssignStmt a[7] = 5
		NAssignStmt a[8] = 7
		NAssignStmt a[9] = 8
		NAssignStmt res = 10
		NAssignStmt res = NCallExp canJump NIdentifierExp a NIdentifierExp res
		NReturnStmt NIdentifierExp res


This is test IR: 95_jump_game.sy 

Segmentation fault


This is test: 96_int_split.sy 

int N;

int newline;

int split(int n ,int a[])
{
    int i;
    i=N-1;
    while(i!=-1)
    {
        a[i]=n%10;
        n=n/10;
        i=i-1;

    }

    return 0;
}

int main()
{
    N=4;
    newline=10;
    int i;
    int m;
    int b[4];
    m = 1478;
    m = split(m,b);
    int t;
    i=0;
    while(i<4)
    {
        t=b[i];
        putint(t);
        putch(newline);
        i=i+1;

    }
    return 0;
}


This is test AST: 96_int_split.sy 

NCompUnit
	NVarDecl  int N noinit
	NVarDecl  int newline noinit
	NFuncDecl int split
		NVarDecl  int n noinit
		NVarDecl  int a noinit
		NDeclStmt NVarDecl  int i noinit 
		NAssignStmt i = NBinaryExp NIdentifierExp N - 1
		NWhileStmt NBinaryExp NIdentifierExp i != NUnaryExp 277 1 
			While: NBlockStmt
			NAssignStmt a[NIdentifierExp i] = NBinaryExp NIdentifierExp n % 10
			NAssignStmt n = NBinaryExp NIdentifierExp n / 10
			NAssignStmt i = NBinaryExp NIdentifierExp i - 1
		NReturnStmt 0
	NFuncDecl int main
		NAssignStmt N = 4
		NAssignStmt newline = 10
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int m noinit 
		NDeclStmt NVarDecl  int b[4] noinit 
		NAssignStmt m = 1478
		NAssignStmt m = NCallExp split NIdentifierExp m NIdentifierExp b
		NDeclStmt NVarDecl  int t noinit 
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 4 
			While: NBlockStmt
			NAssignStmt t = NIdentifierExp b NIdentifierExp i
			NExpStmt NCallExp putint NIdentifierExp t
			NExpStmt NCallExp putch NIdentifierExp newline
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NReturnStmt 0


This is test IR: 96_int_split.sy 


undefind global identifier


This is test: 97_enc_dec.sy 

int enc(int a)
{
   if(a>25)
   a=a+60;
   else
   {
       a=a-15;
   }
   
   return a;

}

int dec(int a)
{
    if (a>85)
    a=a-59;
    else
    {
        a=a+14;
    }

    return a;
    
}

int main()
{
    int a;
    a=400;
    int res;
    res=enc(a);
    res=dec(res);
    putint(res);
    res = 10;
    putch(res);
    return 0;
}


This is test AST: 97_enc_dec.sy 

NCompUnit
	NFuncDecl int enc
		NVarDecl  int a noinit
		NIfStmt NBinaryExp NIdentifierExp a > 25 
			True: NAssignStmt a = NBinaryExp NIdentifierExp a + 60
			False: NBlockStmt
			NAssignStmt a = NBinaryExp NIdentifierExp a - 15
		NReturnStmt NIdentifierExp a
	NFuncDecl int dec
		NVarDecl  int a noinit
		NIfStmt NBinaryExp NIdentifierExp a > 85 
			True: NAssignStmt a = NBinaryExp NIdentifierExp a - 59
			False: NBlockStmt
			NAssignStmt a = NBinaryExp NIdentifierExp a + 14
		NReturnStmt NIdentifierExp a
	NFuncDecl int main
		NDeclStmt NVarDecl  int a noinit 
		NAssignStmt a = 400
		NDeclStmt NVarDecl  int res noinit 
		NAssignStmt res = NCallExp enc NIdentifierExp a
		NAssignStmt res = NCallExp dec NIdentifierExp res
		NExpStmt NCallExp putint NIdentifierExp res
		NAssignStmt res = 10
		NExpStmt NCallExp putch NIdentifierExp res
		NReturnStmt 0


This is test IR: 97_enc_dec.sy 

Function: enc entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 2076849712			int:60		int: 2076849712		
		Br argNum:2 
Instruction: 		GT argNum:2 
Instruction: 		Load argNum:1 int: 2076849712			int:25		Block or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 2076849712			int:15		int: 2076849712		
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 2076849712		

Function: dec entry = 0 succ_bbs_= 1 
    BlockType 0 InstructionListLength = 2
		Store argNum:2 
Instruction: 		Sub argNum:2 
Instruction: 		Load argNum:1 int: 2076849712			int:59		int: 2076849712		
		Br argNum:2 
Instruction: 		GT argNum:2 
Instruction: 		Load argNum:1 int: 2076849712			int:85		Block or something
    BlockType 0 InstructionListLength = 1
		Store argNum:2 
Instruction: 		Add argNum:2 
Instruction: 		Load argNum:1 int: 2076849712			int:14		int: 2076849712		
    BlockType 0 InstructionListLength = 1
		Load argNum:1 int: 2076849712		

Function: main entry = 0 succ_bbs_= 0 
    BlockType 0 InstructionListLength = 9
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 0		
		Store argNum:2 int:400	int: 0		
		Alloca argNum:0 
		Store argNum:2 int: 0		int: 1		
		Store argNum:2 
Instruction: 		Call argNum:2 
Instruction: 		Load argNum:1 int: 0			Block or something	int: 1		
		Store argNum:2 
Instruction: 		Call argNum:2 
Instruction: 		Load argNum:1 int: 1			Block or something	int: 1		
		Store argNum:2 int:10	int: 1		
		constant argNum:1 int: 0		



This is test: 98_palindrome_number.sy 

int palindrome(int n)
{
    int a[4];
    int j;
    int flag;
    j=0;
    while(j<4)
    {
        a[j]=n%10;
        n=n/10;
        j=j+1;
    }

    if(a[0]==a[3] && a[1]==a[2])
	{
		flag=1;
	}else{
		flag=0;
	}
	return flag;
}

int main()
{
    int test;
    test=1221;
    int flag;
    flag=palindrome(test);
    if(flag==1)
        putint(test);
    else
    {
        flag = 0;
        putint(flag);
    }

    flag = 10;
    putch(flag);

    return 0;
    
}


This is test AST: 98_palindrome_number.sy 

NCompUnit
	NFuncDecl int palindrome
		NVarDecl  int n noinit
		NDeclStmt NVarDecl  int a[4] noinit 
		NDeclStmt NVarDecl  int j noinit 
		NDeclStmt NVarDecl  int flag noinit 
		NAssignStmt j = 0
		NWhileStmt NBinaryExp NIdentifierExp j < 4 
			While: NBlockStmt
			NAssignStmt a[NIdentifierExp j] = NBinaryExp NIdentifierExp n % 10
			NAssignStmt n = NBinaryExp NIdentifierExp n / 10
			NAssignStmt j = NBinaryExp NIdentifierExp j + 1
		NIfStmt NBinaryExp NBinaryExp NIdentifierExp a 0 == NIdentifierExp a 3 & NBinaryExp NIdentifierExp a 1 == NIdentifierExp a 2 
			True: NBlockStmt
			NAssignStmt flag = 1
			False: NBlockStmt
			NAssignStmt flag = 0
		NReturnStmt NIdentifierExp flag
	NFuncDecl int main
		NDeclStmt NVarDecl  int test noinit 
		NAssignStmt test = 1221
		NDeclStmt NVarDecl  int flag noinit 
		NAssignStmt flag = NCallExp palindrome NIdentifierExp test
		NIfStmt NBinaryExp NIdentifierExp flag == 1 
			True: NExpStmt NCallExp putint NIdentifierExp test
			False: NBlockStmt
			NAssignStmt flag = 0
			NExpStmt NCallExp putint NIdentifierExp flag
		NAssignStmt flag = 10
		NExpStmt NCallExp putch NIdentifierExp flag
		NReturnStmt 0


This is test IR: 98_palindrome_number.sy 


undefind global identifier


This is test: 99_bin_search.sy 


int main()
{
    //newline=10;
    int i;
    int sum;
    int a[10];
    sum=0;
    //m = 1478;
    //int t;
    i=0;
    while(i<10)
    {
        a[i]=i+1;
        i=i+1;
    }
    int x;
    int high;
    int low;
    int mid;
    int n;
    n=10;
    x=getint();
    high=n-1;
    low=0;
    mid=(high+low)/2;
    while(a[mid]!=x && low < high)
    {
        mid=(high+low)/2;
        if(x<a[mid])
            high=mid-1;
            else
            {
                low = mid +1;
            }
       
    }

     if(x==a[mid])
        putint(x);
        else
        {
            x = 0;
            putint(x);
        }
    
    x = 10;
    putch(x);

    return 0;
}


This is test AST: 99_bin_search.sy 

NCompUnit
	NFuncDecl int main
		NDeclStmt NVarDecl  int i noinit 
		NDeclStmt NVarDecl  int sum noinit 
		NDeclStmt NVarDecl  int a[10] noinit 
		NAssignStmt sum = 0
		NAssignStmt i = 0
		NWhileStmt NBinaryExp NIdentifierExp i < 10 
			While: NBlockStmt
			NAssignStmt a[NIdentifierExp i] = NBinaryExp NIdentifierExp i + 1
			NAssignStmt i = NBinaryExp NIdentifierExp i + 1
		NDeclStmt NVarDecl  int x noinit 
		NDeclStmt NVarDecl  int high noinit 
		NDeclStmt NVarDecl  int low noinit 
		NDeclStmt NVarDecl  int mid noinit 
		NDeclStmt NVarDecl  int n noinit 
		NAssignStmt n = 10
		NAssignStmt x = NCallExp getint
		NAssignStmt high = NBinaryExp NIdentifierExp n - 1
		NAssignStmt low = 0
		NAssignStmt mid = NBinaryExp NBinaryExp NIdentifierExp high + NIdentifierExp low / 2
		NWhileStmt NBinaryExp NBinaryExp NIdentifierExp a NIdentifierExp mid != NIdentifierExp x & NBinaryExp NIdentifierExp low < NIdentifierExp high 
			While: NBlockStmt
			NAssignStmt mid = NBinaryExp NBinaryExp NIdentifierExp high + NIdentifierExp low / 2
			NIfStmt NBinaryExp NIdentifierExp x < NIdentifierExp a NIdentifierExp mid 
			True: NAssignStmt high = NBinaryExp NIdentifierExp mid - 1
			False: NBlockStmt
			NAssignStmt low = NBinaryExp NIdentifierExp mid + 1
		NIfStmt NBinaryExp NIdentifierExp x == NIdentifierExp a NIdentifierExp mid 
			True: NExpStmt NCallExp putint NIdentifierExp x
			False: NBlockStmt
			NAssignStmt x = 0
			NExpStmt NCallExp putint NIdentifierExp x
		NAssignStmt x = 10
		NExpStmt NCallExp putch NIdentifierExp x
		NReturnStmt 0


This is test IR: 99_bin_search.sy 


undefind global identifier


